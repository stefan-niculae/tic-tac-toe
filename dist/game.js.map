{"version":3,"sources":["../game.js"],"names":["CELL_STATES","EMPTY","Symbol","X","O","DISPLAY","WIN_DELTAS","deepCopyArray","arr","$","extend","range","n","Array","keys","head","array","length","ReflectiveCell","constructor","domElement","game","_state","click","e","fillCell","state","value","symbol","text","removeClass","clickEvent","cell","isGameOver","nextPlayer","rippleOnClick","switchPlayers","maybeEndGame","addCurrentStateToHistory","Game","size","rootElement","initializeState","cellMatrix","createCells","elements","createDomElements","winner","stateHistory","map","gamesRoot","message","player","status","append","rows","cells","reflectiveCell","cellElements","board","activeSide","historyBoards","history","height","css","_nextPlayer","displayedPlayer","_winner","action","_history","pastBoards","createHistoryBoard","bind","html","container","animate","scrollTop","scrollHeight","winningNeighbors","findWinner","coordinates","highlightWinner","allCells","from","iterateCells","winningCells","findWinningNeighbors","filter","row","col","neighborLines","neighborDeltas","neighborCoords","dx","dy","neighborValues","maybeGetCellState","winningLines","every","v","winningLine","x","y","addClass","nSteps","cellStateMatrix","cellsRow","number","fromState","cellStateRows","rowElements","cellStateRow","cellState","resetToState","pastState","truncatedHistory","slice","createGame"],"mappings":"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","file":"game.js","sourcesContent":["const CELL_STATES = {}\nCELL_STATES.EMPTY = Symbol('Empty Cell')\nCELL_STATES.X = Symbol('X')\nCELL_STATES.O = Symbol('O')\nconst DISPLAY = {}\nDISPLAY[CELL_STATES.EMPTY] = '' // object creation syntax does not work with symbols\nDISPLAY[CELL_STATES.X]     = 'X'\nDISPLAY[CELL_STATES.O]     = 'O'\nconst WIN_DELTAS = [\n    [[0, -1], [0, +1]], // left, right\n    [[-1, 0], [+1, 0]], // above, below\n    [[-1, -1], [+1, +1]], // up-left, down-right\n    [[+1, -1], [-1, +1]], // down-left, up-right\n]\n\n/** Utils **/\ndeepCopyArray = (arr) => $.extend(true, [], arr)\nrange = (n) => [...(new Array(n).keys())]  /* [0, 1, 2, 3, ... ] */\nhead = (array) => {\n    /* First element or null */\n    if (array.length === 0)\n        return null\n    return array[0]\n}\n\n\nclass ReflectiveCell {\n    /* Reflects changes to internal state in the DOM element */\n    constructor(domElement, game) {\n        this._state = CELL_STATES.EMPTY\n        this.domElement = domElement\n            .click(e => ReflectiveCell.fillCell(e, this, game))\n    }\n    set state(value) {\n        /* Show the corresponding symbol */\n        this._state = value\n        let symbol = DISPLAY[value]\n\n        this.domElement.text(symbol)\n        if (value === CELL_STATES.EMPTY)  // empty cell\n            // it will be turned noninteractive when the animation ends\n            this.domElement.removeClass('noninteractive')\n    }\n    get state() { return this._state }\n\n    static fillCell(clickEvent, cell, game) {\n        /* Register the click, updating the game state */\n        if (game.isGameOver)\n            return\n\n        if (cell.state !== CELL_STATES.EMPTY) // cell is already filled\n            return\n        cell.state = game.nextPlayer // actually set the value\n\n        rippleOnClick(clickEvent, cell.domElement)\n\n        game.switchPlayers()\n        game.maybeEndGame()\n        game.addCurrentStateToHistory()\n    }\n}\n\nclass Game {\n    constructor(size, rootElement) {\n        this.size = size\n        this.initializeState(rootElement)\n    }\n\n    /** Initialization **/\n    initializeState(rootElement) {\n        /* Initialize internal values and create DOM elements */\n        this.cellMatrix = this.createCells()\n        this.elements = this.createDomElements(rootElement)\n\n        this.winner = null // null, X or O\n        this.nextPlayer = CELL_STATES.X\n\n        this.stateHistory = []\n        this.addCurrentStateToHistory() // add the initial state\n    }\n\n    createCells() {\n        /* Create the n by n matrix of (reflective) cells */\n        let game = this\n\n        return range(this.size).map(() =>\n            // Create n rows\n            range(this.size).map(() =>\n                // Each row contains n cell elements\n                new ReflectiveCell($('<td>', {'class': 'ripple'}), game)\n            )\n        )\n    }\n\n    createDomElements(gamesRoot) {\n        /* Create and insert the elements into the DOM */\n        // TODO refactor into more readable syntax\n        let message = $('<span>', {'class': 'message'})\n        let player = $('<span>', {'class': 'player'})\n        let status = $('<p>', {'class': 'status'})\n            .append(message)\n            .append(': ')\n            .append(player)\n\n        let rows = this.cellMatrix\n            .map(cells => cells.map(reflectiveCell => reflectiveCell.domElement))\n            .map(cellElements => $('<tr>').append(cellElements))\n        let board = $('<table>', {'class': 'board'}).append(rows)\n\n        let activeSide = $('<div>', {'class': 'active-side'})\n            .append(status)\n            .append(board)\n\n        let historyBoards = $('<div>', {'class': 'boards'})\n        let history = $('<div>', {'class': 'history'})\n            .append('<p>History</p>')\n            .append(historyBoards)\n\n        let game = $('<article>', {'class': 'game'})\n            .append(activeSide)\n            .append(history)\n\n        gamesRoot\n            .append(game)\n            .append('<hr>')\n\n        // Height is only evaluated after the element is inserted in the DOM\n        let height = activeSide.height()\n        history.css({height: height + 'px'})\n\n        return {game, message, player, history, historyBoards}\n    }\n\n    /** Reflective changes in internal cellMatrix in their respective DOM elements **/\n\n    /* The game is over if there exists a winner */\n    get isGameOver() { return (this.winner !== null) }\n\n    set nextPlayer(value) {\n        /* Update the displayed player symbol */\n        this._nextPlayer = value\n        let displayedPlayer = this.isGameOver ? this.winner : this.nextPlayer\n        this.elements.player.text(DISPLAY[displayedPlayer])\n    }\n    get nextPlayer() { return this._nextPlayer }\n\n    set winner(value) {\n        /* Set the message for winning or next player */\n        this._winner = value\n        let message = this.isGameOver ? 'Winner' : 'Next player'\n        this.elements.message.text(message)\n\n        let action = this.isGameOver ? 'addClass' : 'removeClass'\n        this.elements.game[action]('game-over')\n    }\n    get winner() { return this._winner }\n\n\n    set stateHistory(value) {\n        /* Create a board element for each step in the history */\n        this._history = value\n\n        let game = this\n        let pastBoards = this.stateHistory.map(game.createHistoryBoard.bind(game))\n        this.elements.historyBoards.html(pastBoards)\n\n        // Scroll to bottom\n        let container = this.elements.history\n        container.animate({scrollTop: container[0].scrollHeight}, 200)\n    }\n    get stateHistory() { return this._history }\n\n\n    /** Updating **/\n    switchPlayers() {\n        /* X becomes O and vice-versa */\n        this.nextPlayer = (this.nextPlayer === CELL_STATES.X) ?\n            CELL_STATES.O :\n            CELL_STATES.X\n    }\n\n\n    /** Win condition **/\n    maybeEndGame() {\n        /* If there is a winner, end the game; otherwise, do nothing */\n        let winningNeighbors = this.findWinner()\n        if (winningNeighbors === null) // no winner found\n            return\n\n        let {winner, coordinates} = winningNeighbors\n        this.winner = winner\n        this.highlightWinner(coordinates)\n    }\n\n    findWinner() {\n        /* Return the coordinates of winning triplet of cells, if there is one */\n        let game = this\n        let allCells = Array.from(this.iterateCells())\n        let winningCells = allCells\n            .map(game.findWinningNeighbors.bind(game))\n            .filter(winningNeighbors => winningNeighbors !== null)\n        return head(winningCells) // first winning cell or null\n    }\n\n    findWinningNeighbors({row, col, cell}) {\n        /* Check if neighboring cells (left & right, above & below, diagonals) are the same */\n        if (cell.state === CELL_STATES.EMPTY) // there can't be a winner with an empty center\n            return null\n\n        let game = this\n        let neighborLines = WIN_DELTAS.map(neighborDeltas => {\n            let neighborCoords = neighborDeltas.map(([dx, dy]) => [row + dx, col + dy])\n            let neighborValues = neighborCoords.map(game.maybeGetCellState.bind(game))\n            // We filter by the values but keep the coordinates\n            return {neighborCoords, neighborValues}\n        })\n        let winningLines = neighborLines.filter(({neighborCoords, neighborValues}) =>\n            // All neighbors have the same value as the center\n            neighborValues.every(v => v === cell.state)\n        )\n\n        let winningLine = head(winningLines)\n        if (winningLine === null) // no winning lines found\n            return null\n        return {\n            winner: cell.state,\n            coordinates: [...winningLine.neighborCoords, [row, col]]\n        }\n    }\n\n    highlightWinner(coordinates) {\n        /* Highlight the cells that caused the win */\n        for (let {cell} of this.iterateCells())\n            cell.domElement.removeClass('winner')\n\n        for (let [x, y] of coordinates) {\n            let cell = this.cellMatrix[x][y]\n            cell.domElement.addClass('winner')\n        }\n    }\n\n\n    /** History **/\n    addCurrentStateToHistory() {\n        /* The current state contains the value of each cell, the next player and the winner */\n        let nSteps = this.stateHistory.length\n        // Extract the state from each (reflective) cell in the matrix\n        let cellStateMatrix = this.cellMatrix.map(cellsRow =>\n            cellsRow.map(cell => cell.state)\n        )\n\n        // Create a new one instead of pushing into the old one in order to trigger the setter\n        this.stateHistory = [...this.stateHistory, {\n            number: nSteps,\n            nextPlayer: this.nextPlayer,\n            cellStateMatrix: cellStateMatrix,\n            winner: this.winner,\n        }]\n    }\n\n    createHistoryBoard(fromState) {\n        /* Populate the board and add the hook to be able to restore to this state when clicked */\n        let cellStateRows = fromState.cellStateMatrix\n\n        let rowElements = $.map(cellStateRows, cellStateRow => {\n            let cellElements = $.map(cellStateRow, cellState => {\n                let symbol = DISPLAY[cellState]\n                return $('<td>').text(symbol) // cell element\n            })\n            return $('<tr>').append(cellElements) // row element\n        })\n\n        return $('<table>', {'class': 'board'}) // board element\n            .append(rowElements)\n            .click(() => this.resetToState(fromState))\n    }\n\n    resetToState(pastState) {\n        /* Replace the state of each cell, next player and the winner and keep only previous history steps */\n        for (let {row, col, cell} of this.iterateCells())\n            cell.state = pastState.cellStateMatrix[row][col]\n        this.nextPlayer = pastState.nextPlayer\n        this.winner = pastState.winner\n\n        let truncatedHistory = this.stateHistory.slice(0, pastState.number + 1) // keep history up until this step\n        this.stateHistory = deepCopyArray(truncatedHistory)\n    }\n\n\n    /** Utils **/\n    *iterateCells() {\n        /* Go through each cell in the matrix */\n        for (let row = 0; row < this.size; row++)\n            for (let col = 0; col < this.size; col++)\n                yield {\n                    row,\n                    col,\n                    cell: this.cellMatrix[row][col],\n                }\n    }\n\n    maybeGetCellState([row, col]) {\n        /* Returns the value at row x and column y or null if out of bounds */\n        let n = this.size\n        if (row < 0 || row >= n || col < 0 || col >= this.size)\n            return null\n        return this.cellMatrix[row][col].state\n    }\n}\n\nlet gamesRoot = $('#games')\nlet createGame = (n) => new Game(n, gamesRoot)\n"]}