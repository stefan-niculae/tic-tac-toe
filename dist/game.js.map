{"version":3,"sources":["../game.js"],"names":["DISPLAY_SYMBOL","null","WIN_DELTAS","deepCopyArray","arr","$","extend","range","n","Array","keys","head","array","length","ReflectiveCell","constructor","domElement","game","_state","click","e","fillCell","state","value","symbol","text","removeClass","clickEvent","cell","isGameOver","nextPlayer","rippleOnClick","switchPlayers","maybeEndGame","addCurrentStateToHistory","Game","size","rootElement","initializeState","cellMatrix","createCells","elements","createDomElements","winner","stateHistory","map","gamesRoot","message","player","status","append","rows","cells","reflectiveCell","cellElements","board","activeSide","historyBoards","history","height","css","_nextPlayer","displayedPlayer","_winner","action","_history","pastBoards","createHistoryBoard","bind","html","container","animate","scrollTop","scrollHeight","winningNeighbors","findWinner","coordinates","highlightWinner","allCells","from","iterateCells","winningCells","findWinningNeighbors","filter","result","row","col","neighborLines","neighborDeltas","neighborCoords","dx","dy","neighborValues","maybeGetCellState","winningLines","every","v","winningLine","x","y","addClass","nSteps","cellStateMatrix","cellsRow","number","fromState","cellStateRows","rowElements","cellStateRow","cellState","resetToState","pastState","truncatedHistory","slice","createGame"],"mappings":"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","file":"game.js","sourcesContent":["const DISPLAY_SYMBOL = {\n    // mapping from internal value to external display symbol\n    null: '',\n    1: 'X',\n    '-1': 'O', // the letter O is more aesthetic than a zero\n}\nconst WIN_DELTAS = [\n    [[0, -1], [0, +1]], // left, right\n    [[-1, 0], [+1, 0]], // above, below\n    [[-1, -1], [+1, +1]], // up-left, down-right\n    [[+1, -1], [-1, +1]], // down-left, up-right\n]\n\n/** Utils **/\ndeepCopyArray = (arr) => $.extend(true, [], arr)\nrange = (n) => [...Array(n).keys()]  /* [0, 1, 2, 3, ... ] */\nhead = (array) => {\n    /* First element or null */\n    if (array.length === 0)\n        return null\n    return array[0]\n}\n\n\nclass ReflectiveCell {\n    /* Reflects changes to internal state in the DOM element */\n    constructor(domElement, game) {\n        this._state = null // empty TODO create symbol with EMPTY, X, O\n        this.domElement = domElement\n            .click(e => ReflectiveCell.fillCell(e, this, game))\n    }\n    set state(value) {\n        /* Show the corresponding symbol */\n        this._state = value\n        let symbol = DISPLAY_SYMBOL[value]\n\n        this.domElement.text(symbol)\n        if (value === null)  // empty cell\n            // it will be turned noninteractive when the animation ends\n            this.domElement.removeClass('noninteractive')\n    }\n    get state() { return this._state }\n\n    static fillCell(clickEvent, cell, game) {\n        if (game.isGameOver)\n            return\n\n        if (cell.state !== null) // cell is already filled\n            return\n        cell.state = game.nextPlayer // actually set the value\n\n        rippleOnClick(clickEvent, cell.domElement)\n\n        game.switchPlayers()\n        game.maybeEndGame()\n        game.addCurrentStateToHistory()\n    }\n}\n\nclass Game {\n    constructor(size, rootElement) {\n        this.size = size\n\n        this.initializeState(rootElement)\n    }\n\n    /** Initialization **/\n    initializeState(rootElement) {\n        this.cellMatrix = this.createCells()\n        this.elements = this.createDomElements(rootElement) // has to be set after creating cells (need cell matrix)\n\n        this.winner = null // has to be set after creating the elements (need message element)\n        this.nextPlayer = +1 // has to be set after creating elements and setting the winner (message element and content)\n\n        this.stateHistory = []\n        this.addCurrentStateToHistory() // add the initial state\n    }\n\n    createCells() {\n        let game = this\n\n        return range(this.size).map(() =>\n            // Create n rows\n            range(this.size).map(() =>\n                // Each row contains n cell elements\n                new ReflectiveCell($('<td>', {'class': 'ripple'}), game)\n            )\n        )\n    }\n\n    createDomElements(gamesRoot) {\n        // TODO refactor into more readable syntax\n        // Build and insert the elements into the DOM\n        let message = $('<span>', {'class': 'message'})\n        let player = $('<span>', {'class': 'player'})\n        let status = $('<p>', {'class': 'status'})\n            .append(message)\n            .append(': ')\n            .append(player)\n\n        let rows = this.cellMatrix\n            .map(cells => cells.map(reflectiveCell => reflectiveCell.domElement))\n            .map(cellElements => $('<tr>').append(cellElements))\n        let board = $('<table>', {'class': 'board'}).append(rows)\n\n        let activeSide = $('<div>', {'class': 'active-side'})\n            .append(status)\n            .append(board)\n\n        let historyBoards = $('<div>', {'class': 'boards'})\n        let history = $('<div>', {'class': 'history'})\n            .append('<p>History</p>')\n            .append(historyBoards)\n\n        let game = $('<article>', {'class': 'game'})\n            .append(activeSide)\n            .append(history)\n\n        gamesRoot\n            .append(game)\n            .append('<hr>')\n\n        // Height is only evaluated after the element is inserted in the DOM\n        let height = activeSide.height()\n        history.css({height: height + 'px'})\n\n        return {game, message, player, history, historyBoards}\n    }\n\n    /** Reflective changes in internal cellMatrix in their respective DOM elements **/\n\n    /* The game is over if there exists a winner */\n    get isGameOver() { return (this.winner !== null) }\n\n    set nextPlayer(value) {\n        this._nextPlayer = value\n        let displayedPlayer = this.isGameOver ? this.winner : this.nextPlayer\n        this.elements.player.text(DISPLAY_SYMBOL[displayedPlayer])\n    }\n    get nextPlayer() { return this._nextPlayer }\n\n    set winner(value) {\n        this._winner = value\n        let message = this.isGameOver ? 'Winner' : 'Next player'\n        this.elements.message.text(message)\n\n        let action = this.isGameOver ? 'addClass' : 'removeClass'\n        this.elements.game[action]('game-over')\n    }\n    get winner() { return this._winner }\n\n\n    set stateHistory(value) {\n        this._history = value\n\n        let game = this\n        let pastBoards = this.stateHistory.map(game.createHistoryBoard.bind(game))\n        this.elements.historyBoards.html(pastBoards)\n\n        // Scroll to bottom\n        let container = this.elements.history\n        container.animate({scrollTop: container[0].scrollHeight}, 200)\n    }\n    get stateHistory() { return this._history }\n\n\n    /** Updating **/\n    switchPlayers() {\n        this.nextPlayer *= -1\n    }\n\n\n    /** Win condition **/\n    maybeEndGame() {\n        /* If there is a winner, end the game; otherwise, do nothing */\n        let winningNeighbors = this.findWinner()\n        if (winningNeighbors === null) // no winner found\n            return\n\n        let {winner, coordinates} = winningNeighbors\n        this.winner = winner\n        this.highlightWinner(coordinates)\n    }\n\n    findWinner() {\n        /* Return the coordinates of winning triplet of cells, if there is one */\n        let game = this\n        let allCells = Array.from(this.iterateCells())\n        let winningCells = allCells\n            .map(game.findWinningNeighbors.bind(game))\n            .filter(result => result !== null)\n        return head(winningCells) // first winning cell or null\n    }\n\n    findWinningNeighbors({row, col, cell}) {\n        /* Check if neighboring cells (left & right, above & below, diagonals) are the same */\n        if (cell.state === null) // there can't be a winner with an empty center\n            return null\n\n        let game = this\n        let neighborLines = WIN_DELTAS.map(neighborDeltas => {\n            let neighborCoords = neighborDeltas.map(([dx, dy]) => [row + dx, col + dy])\n            let neighborValues = neighborCoords.map(game.maybeGetCellState.bind(game))\n            // We filter by the values but keep the coordinates\n            return {neighborCoords, neighborValues}\n        })\n        let winningLines = neighborLines.filter(({neighborCoords, neighborValues}) =>\n            // All neighbors have the same value as the center\n            neighborValues.every(v => v === cell.state)\n        )\n\n        let winningLine = head(winningLines)\n        if (winningLine === null) // no winning lines found\n            return null\n        return {\n            winner: cell.state,\n            coordinates: [...winningLine.neighborCoords, [row, col]]\n        }\n    }\n\n    highlightWinner(coordinates) {\n        for (let {cell} of this.iterateCells())\n            cell.domElement.removeClass('winner')\n\n        for (let [x, y] of coordinates) {\n            let cell = this.cellMatrix[x][y]\n            cell.domElement.addClass('winner')\n        }\n    }\n\n\n    /** History **/\n    addCurrentStateToHistory() {\n        /* The current state contains the value of each cell, the next player and the winner */\n        let nSteps = this.stateHistory.length\n        // Extract the state from each (reflective) cell in the matrix\n        let cellStateMatrix = this.cellMatrix.map(cellsRow =>\n            cellsRow.map(cell => cell.state)\n        )\n\n        // Create a new one instead of pushing into the old one in order to trigger the setter\n        this.stateHistory = [...this.stateHistory, {\n            number: nSteps,\n            nextPlayer: this.nextPlayer,\n            cellStateMatrix: cellStateMatrix,\n            winner: this.winner,\n        }]\n    }\n\n    createHistoryBoard(fromState) {\n        let cellStateRows = fromState.cellStateMatrix\n\n        let rowElements = $.map(cellStateRows, cellStateRow => {\n            let cellElements = $.map(cellStateRow, cellState => {\n                let symbol = DISPLAY_SYMBOL[cellState]\n                return $('<td>').text(symbol) // cell element\n            })\n            return $('<tr>').append(cellElements) // row element\n        })\n\n        return $('<table>', {'class': 'board'}) // board element\n            .append(rowElements)\n            .click(() => this.resetToState(fromState))\n    }\n\n    resetToState(pastState) {\n        for (let {row, col, cell} of this.iterateCells())\n            cell.state = pastState.cellStateMatrix[row][col]\n        this.nextPlayer = pastState.nextPlayer\n        this.winner = pastState.winner\n\n        let truncatedHistory = this.stateHistory.slice(0, pastState.number + 1) // keep stateHistory up until this step\n        this.stateHistory = deepCopyArray(truncatedHistory)\n    }\n\n\n    /** Utils **/\n    *iterateCells() {\n        for (let row = 0; row < this.size; row++)\n            for (let col = 0; col < this.size; col++)\n                yield {\n                    row,\n                    col,\n                    cell: this.cellMatrix[row][col],\n                }\n    }\n\n    maybeGetCellState([row, col]) {\n        /* Returns the value at row x and column y or null if out of bounds */\n        let n = this.size\n        if (row < 0 || row >= n || col < 0 || col >= this.size)\n            return null\n        return this.cellMatrix[row][col].state\n    }\n}\n\nlet gamesRoot = $('#games')\nlet createGame = (n) => new Game(n, gamesRoot)\n"]}