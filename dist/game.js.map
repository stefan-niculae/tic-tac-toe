{"version":3,"sources":["../game.js"],"names":["CELL_STATES","EMPTY","Symbol","X","O","DISPLAY","WIN_DELTAS","GAMES_ROOT","$","createGame","n","Game","deepCopyArray","arr","extend","range","Array","keys","head","array","length","constructor","size","rootElement","initializeState","cellMatrix","createCells","domElements","createDomElements","winner","nextPlayer","stateHistory","addCurrentStateToHistory","game","map","_","ReflectiveCell","gamesRoot","message","player","status","append","rows","cells","reflectiveCell","domElement","cellElements","board","activeSide","historyBoards","history","height","css","isGameOver","value","_nextPlayer","displayedPlayer","text","_winner","action","_history","pastBoards","createHistoryBoard","bind","html","container","animate","scrollTop","scrollHeight","switchPlayers","maybeEndGame","winningNeighbors","findWinner","coordinates","highlightWinner","allCells","from","iterateCells","winningCells","findWinningNeighbors","filter","row","col","cell","state","neighborLines","neighborDeltas","neighborCoords","dx","dy","neighborValues","maybeGetCellState","winningLines","every","v","winningLine","removeClass","x","y","addClass","nSteps","cellStateMatrix","cellsRow","number","fromState","cellStateRows","rowElements","cellStateRow","cellState","symbol","click","resetToState","pastState","truncatedHistory","slice","_state","e","fillCell","clickEvent","rippleOnClick"],"mappings":"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","file":"game.js","sourcesContent":["const CELL_STATES = {}\nCELL_STATES.EMPTY = Symbol('Empty Cell')\nCELL_STATES.X     = Symbol('X')\nCELL_STATES.O     = Symbol('O')\nconst DISPLAY = {}\nDISPLAY[CELL_STATES.EMPTY] = '' // object creation syntax does not work with symbols\nDISPLAY[CELL_STATES.X]     = 'X'\nDISPLAY[CELL_STATES.O]     = 'O'\nconst WIN_DELTAS = [\n    [[0, -1], [0, +1]], // left, right\n    [[-1, 0], [+1, 0]], // above, below\n    [[-1, -1], [+1, +1]], // up-left, down-right\n    [[+1, -1], [-1, +1]], // down-left, up-right\n]\n// TODO: const instead of let (almost everywhere)\nconst GAMES_ROOT = $('#games')\nfunction createGame(n) {\n    new Game(n, GAMES_ROOT)\n}\n\n/** Utils **/\ndeepCopyArray = (arr) => $.extend(true, [], arr)\n// TODO: alternative to Array(n)\nrange = (n) => [...(new Array(n).keys())]  /* range(4) ~> [0, 1, 2, 3] */\nhead = (array) => {\n    /* First element or null */\n    if (array.length === 0)\n        return null\n    return array[0]\n}\n\n\nclass Game {\n    constructor(size, rootElement) {\n        this.size = size\n        this.initializeState(rootElement)\n    }\n\n    /** Initialization **/\n    initializeState(rootElement) {\n        /* Initialize internal values and create DOM domElements */\n        this.cellMatrix = this.createCells()\n        this.domElements = this.createDomElements(rootElement)\n\n        this.winner = null // can be null, X or O\n        this.nextPlayer = CELL_STATES.X\n\n        this.stateHistory = []\n        this.addCurrentStateToHistory() // add the initial state\n    }\n\n    createCells() {\n        /* Create the n by n matrix of (reflective) cells */\n        let game = this\n\n        return range(this.size).map(_ =>\n            // Create n rows\n            range(this.size).map(_ =>\n                // Each row contains n cell elements\n                new ReflectiveCell($('<td>', {'class': 'ripple'}), game)\n            )\n        )\n    }\n\n    createDomElements(gamesRoot) {\n        /* Create and insert the elements into the DOM */\n        // TODO refactor into more readable syntax\n        let message = $('<span>', {'class': 'message'})\n        let player = $('<span>', {'class': 'player'})\n        let status = $('<p>', {'class': 'status'})\n            .append(message)\n            .append(': ')\n            .append(player)\n\n        let rows = this.cellMatrix\n            .map(cells => cells.map(reflectiveCell => reflectiveCell.domElement))\n            .map(cellElements => $('<tr>').append(cellElements))\n        let board = $('<table>', {'class': 'board'}).append(rows)\n\n        let activeSide = $('<div>', {'class': 'active-side'})\n            .append(status)\n            .append(board)\n\n        let historyBoards = $('<div>', {'class': 'boards'})\n        let history = $('<div>', {'class': 'history'})\n            .append('<p>History</p>')\n            .append(historyBoards)\n\n        let game = $('<article>', {'class': 'game'})\n            .append(activeSide)\n            .append(history)\n\n        gamesRoot\n            .append(game)\n            .append('<hr>')\n\n        // Height is only evaluated after the element is inserted in the DOM\n        let height = activeSide.height()\n        history.css({height: height + 'px'})\n\n        return {game, message, player, history, historyBoards}\n    }\n\n    /** Reflective changes in internal cellMatrix in their respective DOM elements **/\n\n    /* The game is over if there exists a winner */\n    get isGameOver() { return (this.winner !== null) }\n\n    set nextPlayer(value) {\n        /* Update the displayed player symbol */\n        this._nextPlayer = value\n        const displayedPlayer = this.isGameOver ? this.winner : this.nextPlayer\n        this.domElements.player.text(DISPLAY[displayedPlayer])\n    }\n    get nextPlayer() { return this._nextPlayer }\n\n    set winner(value) {\n        /* Set the message for winning or next player\n            this field changes when resetting the game by clicking on a previous state in the history\n        * */\n        this._winner = value\n        let message = this.isGameOver ? 'Winner' : 'Next player'\n        this.domElements.message.text(message)\n\n        let action = this.isGameOver ? 'addClass' : 'removeClass'\n        this.domElements.game[action]('game-over')\n    }\n    get winner() { return this._winner }\n\n\n    set stateHistory(value) {\n        /* Create a board element for each step in the history */\n        this._history = value\n\n        let game = this\n        let pastBoards = this.stateHistory.map(game.createHistoryBoard.bind(game))\n        this.domElements.historyBoards.html(pastBoards)\n\n        // Scroll to bottom\n        let container = this.domElements.history\n        container.animate({scrollTop: container[0].scrollHeight}, 200)\n    }\n    get stateHistory() { return this._history }\n\n\n    /** Updating **/\n    switchPlayers() {\n        /* X becomes O and vice-versa */\n        this.nextPlayer = (this.nextPlayer === CELL_STATES.X) ?\n            CELL_STATES.O :\n            CELL_STATES.X\n    }\n\n\n    /** Win condition **/\n    maybeEndGame() {\n        /* If there is a winner, end the game; otherwise, do nothing */\n        let winningNeighbors = this.findWinner()\n        if (winningNeighbors === null) // no winner found\n            return\n\n        let {winner, coordinates} = winningNeighbors\n        this.winner = winner\n        this.highlightWinner(coordinates)\n    }\n\n    findWinner() {\n        /* Return the coordinates of winning triplet of cells, if there is one */\n        let game = this\n        let allCells = Array.from(this.iterateCells())\n        let winningCells = allCells // there can be multiple winning triplets at the same time\n            .map(game.findWinningNeighbors.bind(game))\n            .filter(winningNeighbors => winningNeighbors !== null)\n        return head(winningCells) // first winning cell or null\n    }\n\n    findWinningNeighbors({row, col, cell}) {\n        /* Check if neighboring cells (left & right, above & below, diagonals) are the same */\n        if (cell.state === CELL_STATES.EMPTY) // there can't be a winner with an empty center\n            return null\n\n        let game = this\n        let neighborLines = WIN_DELTAS.map(neighborDeltas => {\n            let neighborCoords = neighborDeltas.map(([dx, dy]) => [row + dx, col + dy])\n            let neighborValues = neighborCoords.map(game.maybeGetCellState.bind(game))\n            // We filter by the values but keep the coordinates\n            return {neighborCoords, neighborValues}\n        })\n        // There can be multiple winning lines at a time (eg: vertically and horizontally)\n        let winningLines = neighborLines.filter(({neighborCoords, neighborValues}) =>\n            // All neighbors have the same value as the center\n            neighborValues.every(v => v === cell.state),\n        )\n\n        let winningLine = head(winningLines)\n        if (winningLine === null) // no winning lines found\n            return null\n        return {\n            winner: cell.state,\n            coordinates: [...winningLine.neighborCoords, [row, col]],\n        }\n    }\n\n    highlightWinner(coordinates) {\n        /* Highlight the cells that caused the win */\n        for (let {cell} of this.iterateCells())\n            cell.domElement.removeClass('winner')\n\n        for (let [x, y] of coordinates) {\n            let cell = this.cellMatrix[x][y]\n            cell.domElement.addClass('winner')\n        }\n    }\n\n\n    /** History **/\n    addCurrentStateToHistory() {\n        /* The current state contains the value of each cell, the next player and the winner */\n        let nSteps = this.stateHistory.length\n        // Extract the state from each (reflective) cell in the matrix\n        let cellStateMatrix = this.cellMatrix.map(cellsRow =>\n            cellsRow.map(cell => cell.state),\n        )\n\n        // Create a new one instead of pushing into the old one in order to trigger the setter\n        this.stateHistory = [...this.stateHistory, {\n            number: nSteps,\n            nextPlayer: this.nextPlayer,\n            cellStateMatrix: cellStateMatrix,\n            winner: this.winner,\n        }]\n    }\n\n    createHistoryBoard(fromState) {\n        /* Populate the board and add the hook to be able to restore to this state when clicked */\n        let cellStateRows = fromState.cellStateMatrix\n\n        let rowElements = $.map(cellStateRows, cellStateRow => {\n            let cellElements = $.map(cellStateRow, cellState => {\n                let symbol = DISPLAY[cellState]\n                return $('<td>').text(symbol) // cell element\n            })\n            return $('<tr>').append(cellElements) // row element\n        })\n\n        return $('<table>', {'class': 'board'}) // board element\n            .append(rowElements)\n            .click(() => this.resetToState(fromState))\n    }\n\n    resetToState(pastState) {\n        /* Replace the state of each cell, next player and the winner and keep only previous history steps */\n        for (let {row, col, cell} of this.iterateCells())\n            cell.state = pastState.cellStateMatrix[row][col]\n        this.nextPlayer = pastState.nextPlayer\n        this.winner = pastState.winner\n\n        let truncatedHistory = this.stateHistory.slice(0, pastState.number + 1) // keep history up until this step\n        this.stateHistory = deepCopyArray(truncatedHistory)\n    }\n\n\n    /** Utils **/\n    *iterateCells() {\n        /* Go through each cell in the matrix */\n        for (let row = 0; row < this.size; row++)\n            for (let col = 0; col < this.size; col++)\n                yield {\n                    row,\n                    col,\n                    cell: this.cellMatrix[row][col],\n                }\n    }\n\n    maybeGetCellState([row, col]) {\n        /* Returns the value at the given row and column or null if out of bounds */\n        let n = this.size\n        if (row < 0 || row >= n || col < 0 || col >= this.size)\n            return null\n        return this.cellMatrix[row][col].state\n    }\n}\n\nclass ReflectiveCell {\n    /* Reflects changes to internal state in the DOM element */\n    constructor(domElement, game) {\n        this._state = CELL_STATES.EMPTY\n        this.domElement = domElement\n            .click(e => ReflectiveCell.fillCell(e, this, game))\n    }\n    set state(value) {\n        /* Show the corresponding symbol */\n        this._state = value\n        let symbol = DISPLAY[value]\n\n        this.domElement.text(symbol)\n        if (value === CELL_STATES.EMPTY)  // empty cell\n            // it will be turned noninteractive when the animation ends\n            this.domElement.removeClass('noninteractive')\n    }\n    get state() { return this._state }\n\n    static fillCell(clickEvent, cell, game) {\n        /* Register the click, updating the game state */\n        if (game.isGameOver)\n            return\n\n        if (cell.state !== CELL_STATES.EMPTY) // cell is already filled\n            return\n        cell.state = game.nextPlayer // actually set the value\n\n        rippleOnClick(clickEvent, cell.domElement)\n\n        game.switchPlayers()\n        game.maybeEndGame()\n        game.addCurrentStateToHistory()\n    }\n}\n"]}