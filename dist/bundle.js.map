{"version":3,"sources":["webpack:///bundle.js","webpack:///webpack/bootstrap 4925b326184029a102fb","webpack:///./src/constants.js","webpack:///./src/index.js","webpack:///./src/Game.js","webpack:///./src/BoardCell.js","webpack:///./src/ripple.js","webpack:///./src/utils.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_defineProperty","obj","key","value","writable","_Object$freeze","_Object$freeze2","CELL_STATES","freeze","EMPTY","Symbol","X","O","CELL_DISPLAY","GAME_PHASES","ACTIVE","OVER","DRAW","STATUS_MESSAGES","WINNING_LINES_DELTAS","_Game","_Game2","default","GAMES_ROOT","document","getElementById","BUTTONS","getElementsByClassName","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","iterator","next","done","button","size","getAttribute","onclick","err","return","_toConsumableArray","arr","Array","isArray","arr2","length","from","_classCallCheck","instance","Constructor","TypeError","_slicedToArray","sliceIterator","_arr","_n","_d","_e","_s","_i","push","_createClass","defineProperties","target","props","descriptor","protoProps","staticProps","_BoardCell","_BoardCell2","_constants","_utils","Game","boardSize","rootElement","this","cellMatrix","createCells","domElements","createDomElements","phase","turnNumber","stateHistory","_this","range","map","_","gamesRoot","gameElement","parseHtml","template","rowElements","cells","reflectiveCell","domElement","cellElements","row","createElement","append","apply","boardElement","appendChild","height","scrollHeight","style","game","message","player","history","historyBoards","col","state","winningCoordinates","searchWinningCoordinates","highlightWinner","addCurrentStateToHistory","_this2","winningLinesInfo","flatCells","cellInfo","searchWinningNeighbors","filter","winningLine","head","_ref","_this3","center","cell","neighborLines","lineDeltas","neighborCoordinates","_ref2","_ref3","dx","dy","neighborValues","_ref4","_ref5","x","y","maybeGetCellState","winningLines","_ref6","every","v","concat","coordinates","_this4","forEach","_ref7","classList","remove","_ref8","_ref9","add","cellStateMatrix","cellsRow","pastState","_ref10","truncatedHistory","slice","deepCopyArray","fromState","_this5","cellStateRow","cellState","cellElement","textContent","rowElement","resetToState","set","_phase","_turnNumber","currentPlayer","statesList","_domElements$historyB","_this6","_history","pastBoards","createHistoryBoard","removeChildren","container","scrollTop","_ref11","_this7","cellsByRow","j","_ripple","_ripple2","BoardCell","_state","e","fillCell","clickEvent","setTimeout","advanceTurn","getOrCreate","parent","className","elements","element","prepend","rippleOnClick","event","surface","ink","diameter","Math","max","offsetHeight","offsetWidth","width","pageX","offsetLeft","pageY","offsetTop","left","top","assign","keys","array","templateString","DOMParser","parseFromString","firstChild","removeChild"],"mappings":"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","file":"bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _Object$freeze, _Object$freeze2;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar CELL_STATES = Object.freeze({\n    EMPTY: Symbol('Empty Cell'),\n    X: Symbol('X'),\n    O: Symbol('O')\n});\n\nvar CELL_DISPLAY = Object.freeze((_Object$freeze = {}, _defineProperty(_Object$freeze, CELL_STATES.EMPTY, ''), _defineProperty(_Object$freeze, CELL_STATES.X, 'X'), _defineProperty(_Object$freeze, CELL_STATES.O, 'O'), _Object$freeze));\n\nvar GAME_PHASES = Object.freeze({\n    ACTIVE: Symbol('Game Active'),\n    OVER: Symbol('Game Over'),\n    DRAW: Symbol('Draw')\n});\nvar STATUS_MESSAGES = Object.freeze((_Object$freeze2 = {}, _defineProperty(_Object$freeze2, GAME_PHASES.ACTIVE, 'Next player: '), _defineProperty(_Object$freeze2, GAME_PHASES.OVER, 'Winner: '), _defineProperty(_Object$freeze2, GAME_PHASES.DRAW, 'Draw'), _Object$freeze2));\nvar WINNING_LINES_DELTAS = [\n/* A winning line can be vertical, horizontal or diagonal. Each element in this list corresponds to one line.\n   Each line is composed of the center and the two neighbors.\n   The numbers represent the row and column deltas from the center.\n */\n[[0, -1], [0, +1]], // horizontal line: left, right\n[[-1, 0], [+1, 0]], // vertical line: above, below\n[[-1, -1], [+1, +1]], // diagonal line: up-left, down-right\n[[+1, -1], [-1, +1]]];\n\nexports.CELL_STATES = CELL_STATES;\nexports.CELL_DISPLAY = CELL_DISPLAY;\nexports.GAME_PHASES = GAME_PHASES;\nexports.STATUS_MESSAGES = STATUS_MESSAGES;\nexports.WINNING_LINES_DELTAS = WINNING_LINES_DELTAS;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n__webpack_require__(2);\n\nvar _Game = __webpack_require__(3);\n\nvar _Game2 = _interopRequireDefault(_Game);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar GAMES_ROOT = document.getElementById('games');\nvar BUTTONS = document.getElementsByClassName('add-button');\n\nvar _loop = function _loop(button) {\n    var size = button.getAttribute('data-game-size');\n    button.onclick = function () {\n        return new _Game2.default(+size, GAMES_ROOT);\n    };\n};\n\nvar _iteratorNormalCompletion = true;\nvar _didIteratorError = false;\nvar _iteratorError = undefined;\n\ntry {\n    for (var _iterator = BUTTONS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var button = _step.value;\n\n        _loop(button);\n    }\n} catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n} finally {\n    try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n        }\n    } finally {\n        if (_didIteratorError) {\n            throw _iteratorError;\n        }\n    }\n}\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _BoardCell = __webpack_require__(4);\n\nvar _BoardCell2 = _interopRequireDefault(_BoardCell);\n\nvar _constants = __webpack_require__(0);\n\nvar _utils = __webpack_require__(6);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Game = function () {\n    /* Holds the game board (matrix of cells) and game status (game phase, next player and winner).\n       Creates the DOM elements and defines how turns are advanced (fill board cell, switch players);\n       how the game ends (finding a winning line and restricting interactivity)\n       and how the game state is stored as history and reset.\n     */\n\n    function Game(boardSize, rootElement) {\n        _classCallCheck(this, Game);\n\n        /* Initialize internal values and create DOM elements */\n        this.boardSize = boardSize;\n\n        this.cellMatrix = this.createCells();\n        this.domElements = this.createDomElements(rootElement);\n\n        this.phase = _constants.GAME_PHASES.ACTIVE;\n        this.turnNumber = 1;\n        this.stateHistory = [];\n\n        // this.addCurrentStateToHistory() // add the initial state\n    }\n\n    /** Initialization **/\n\n\n    _createClass(Game, [{\n        key: 'createCells',\n        value: function createCells() {\n            var _this = this;\n\n            /* Create the n by n matrix of (reflective) cells */\n            return (0, _utils.range)(this.boardSize).map(function (_) {\n                return (// create n rows\n                    (0, _utils.range)(_this.boardSize).map(function (_) {\n                        return new _BoardCell2.default(_this);\n                    })\n                );\n            } // each containing n cell elements\n            );\n        }\n    }, {\n        key: 'createDomElements',\n        value: function createDomElements(gamesRoot) {\n            /* Create and insert the into the DOM elements for each part of the game */\n            var template = '\\n          <article class=\"game\">\\n            \\n            <div class=\"active-side\">\\n              <p class=\"status\">\\n                <span class=\"message\"></span><span class=\"player\"></span>\\n              </p>\\n              \\n              <table class=\"board\">\\n              </table>\\n            </div>\\n\\n            <div class=\"history\">\\n              <p>History</p>\\n              <div class=\"boards\">\\n              </div>\\n            </div>       \\n              \\n          </article>\\n        ';\n            var gameElement = (0, _utils.parseHtml)(template).getElementsByClassName('game')[0];\n\n            // Insert the rows of cells to the board element\n            var rowElements = this.cellMatrix.map(function (cells) {\n                return cells.map(function (reflectiveCell) {\n                    return reflectiveCell.domElement;\n                });\n            }).map(function (cellElements) {\n                var row = document.createElement('tr');\n                row.append.apply(row, _toConsumableArray(cellElements));\n                return row;\n            });\n\n            var boardElement = gameElement.getElementsByClassName('board')[0];\n            boardElement.append.apply(boardElement, _toConsumableArray(rowElements));\n\n            // Insert the newly created game into the container of games\n            gamesRoot.appendChild(gameElement);\n\n            // Height is only evaluated after the element is inserted in the DOM\n            var height = gameElement.getElementsByClassName('active-side')[0].scrollHeight;\n            gameElement.getElementsByClassName('history')[0].style.height = height + 'px';\n\n            return {\n                game: gameElement,\n                message: gameElement.getElementsByClassName('message')[0],\n                player: gameElement.getElementsByClassName('player')[0],\n                history: gameElement.getElementsByClassName('history')[0],\n                historyBoards: gameElement.getElementsByClassName('boards')[0]\n            };\n        }\n\n        /** Reflective properties **/\n\n    }, {\n        key: 'maybeGetCellState',\n        value: function maybeGetCellState(row, col) {\n            /* The value at the given row and column or null if out of bounds */\n            var n = this.boardSize;\n            if (row < 0 || row >= n || col < 0 || col >= this.boardSize) return null;\n            return this.cellMatrix[row][col].state;\n        }\n\n        /** Updating **/\n\n    }, {\n        key: 'advanceTurn',\n        value: function advanceTurn() {\n            /* Switch players (X becomes O and vice-versa) and check if game is over or a draw */\n            var winningCoordinates = this.searchWinningCoordinates();\n            if (winningCoordinates !== null) {\n                // actual winning line found\n                this.phase = _constants.GAME_PHASES.OVER;\n                this.highlightWinner(winningCoordinates);\n                return;\n            }\n\n            this.turnNumber += 1;\n            if (this.turnNumber > this.boardSize * this.boardSize) {\n                this.phase = _constants.GAME_PHASES.DRAW; // means it's a draw\n                return;\n            }\n\n            this.addCurrentStateToHistory();\n        }\n\n        /** Win condition **/\n\n    }, {\n        key: 'searchWinningCoordinates',\n        value: function searchWinningCoordinates() {\n            var _this2 = this;\n\n            /* Return the coordinates of winning triplet of cells (and the symbol that won); null if there is none */\n            var winningLinesInfo = this.flatCells // there can be multiple winning triplets at the same time\n            .map(function (cellInfo) {\n                return _this2.searchWinningNeighbors(cellInfo);\n            }).filter(function (winningLine) {\n                return winningLine !== null;\n            });\n            return (0, _utils.head)(winningLinesInfo); // first or null\n        }\n    }, {\n        key: 'searchWinningNeighbors',\n        value: function searchWinningNeighbors(_ref) {\n            var _this3 = this;\n\n            var row = _ref.row,\n                col = _ref.col,\n                center = _ref.cell;\n\n            /* Return the coordinates of the winning line (vertical/horizontal/ diagonals); null if there is none. */\n            // There can't be a winner with an empty center (but there can be a hypothetical one\n            if (center.state === _constants.CELL_STATES.EMPTY) return null;\n\n            var neighborLines = _constants.WINNING_LINES_DELTAS.map(function (lineDeltas) {\n                var neighborCoordinates = lineDeltas.map(function (_ref2) {\n                    var _ref3 = _slicedToArray(_ref2, 2),\n                        dx = _ref3[0],\n                        dy = _ref3[1];\n\n                    return [row + dx, col + dy];\n                });\n                var neighborValues = neighborCoordinates.map(function (_ref4) {\n                    var _ref5 = _slicedToArray(_ref4, 2),\n                        x = _ref5[0],\n                        y = _ref5[1];\n\n                    return _this3.maybeGetCellState(x, y);\n                });\n                // We filter by the values but keep the coordinates\n                return { neighborCoordinates: neighborCoordinates, neighborValues: neighborValues };\n            });\n\n            // There can be multiple winning lines at a time (eg: vertically and horizontally)\n            var winningLines = neighborLines.filter(function (_ref6) {\n                var neighborCoordinates = _ref6.neighborCoordinates,\n                    neighborValues = _ref6.neighborValues;\n                return (\n                    // All neighbors must have the same value as the center\n                    neighborValues.every(function (v) {\n                        return v === center.state;\n                    })\n                );\n            });\n\n            if (winningLines.length === 0) // no winning lines found\n                return null;\n            return [[row, col]].concat(_toConsumableArray(winningLines[0].neighborCoordinates));\n        }\n    }, {\n        key: 'highlightWinner',\n        value: function highlightWinner(coordinates) {\n            var _this4 = this;\n\n            /* Highlight the cells that caused the win */\n            this.flatCells.forEach(function (_ref7) {\n                var cell = _ref7.cell;\n                return cell.domElement.classList.remove('winner');\n            });\n            coordinates.forEach(function (_ref8) {\n                var _ref9 = _slicedToArray(_ref8, 2),\n                    x = _ref9[0],\n                    y = _ref9[1];\n\n                return _this4.cellMatrix[x][y].domElement.classList.add('winner');\n            });\n        }\n\n        /** History **/\n\n    }, {\n        key: 'addCurrentStateToHistory',\n        value: function addCurrentStateToHistory() {\n            /* The current state contains the value of each cell, the next player and the winner status.\n               This method is called after a cell is filled.\n             */\n            // Extract the state from each (reflective) cell in the matrix\n            var cellStateMatrix = this.cellMatrix.map(function (cellsRow) {\n                return cellsRow.map(function (cell) {\n                    return cell.state;\n                });\n            });\n\n            // Create a new one instead of pushing into the old one in order to trigger the setter\n            this.stateHistory = [].concat(_toConsumableArray(this.stateHistory), [{\n                cellStateMatrix: cellStateMatrix,\n                phase: this.phase,\n                turnNumber: this.turnNumber\n                // The history array is not being saved, instead it will be truncated to previous turns\n            }]);\n        }\n    }, {\n        key: 'resetToState',\n        value: function resetToState(pastState) {\n            /* Replace the state of each cell, the next player and the winner and keep only previous history steps */\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = this.flatCells[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var _ref10 = _step.value;\n                    var row = _ref10.row;\n                    var col = _ref10.col;\n                    var cell = _ref10.cell;\n\n                    cell.state = pastState.cellStateMatrix[row][col];\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            this.phase = pastState.phase;\n            this.turnNumber = pastState.turnNumber;\n\n            var truncatedHistory = this.stateHistory.slice(0, pastState.turnNumber); // discard future steps\n            this.stateHistory = (0, _utils.deepCopyArray)(truncatedHistory);\n        }\n    }, {\n        key: 'createHistoryBoard',\n        value: function createHistoryBoard(fromState) {\n            var _this5 = this;\n\n            /* Populate the board and add the hook to be able to restore to this state when clicked */\n            var rowElements = fromState.cellStateMatrix.map(function (cellStateRow) {\n                var cellElements = cellStateRow.map(function (cellState) {\n                    var cellElement = document.createElement('td');\n                    cellElement.textContent = _constants.CELL_DISPLAY[cellState];\n                    return cellElement;\n                });\n\n                var rowElement = document.createElement('tr');\n                rowElement.append.apply(rowElement, _toConsumableArray(cellElements));\n                return rowElement;\n            });\n\n            var boardElement = document.createElement('table');\n            boardElement.classList.add('board');\n            boardElement.onclick = function () {\n                return _this5.resetToState(fromState);\n            };\n            boardElement.append.apply(boardElement, _toConsumableArray(rowElements));\n            return boardElement;\n        }\n    }, {\n        key: 'phase',\n        set: function set(value) {\n            /* Update the displayed message and game class. This field changes when a winning line\n               or a draw was detected after a cell is filled (or when resetting history to an earlier state)\n            */\n            this._phase = value;\n\n            if (this.phase === _constants.GAME_PHASES.ACTIVE)\n                // Clear previous classes (over/draw)\n                this.domElements.game.classList.remove('game-over', 'draw');else\n                // Add the appropriate game over or draw class\n                this.domElements.game.classList.add(this.phase === _constants.GAME_PHASES.OVER ? 'game-over' : 'draw');\n\n            this.domElements.message.textContent = _constants.STATUS_MESSAGES[this.phase];\n        },\n        get: function get() {\n            return this._phase;\n        }\n    }, {\n        key: 'turnNumber',\n        set: function set(value) {\n            /* Update the displayed player symbol and place the current game state in the history.\n               This field changes after a cell is filled (or when resetting history to an earlier state)\n            */\n            this._turnNumber = value;\n            this.domElements.player.textContent = _constants.CELL_DISPLAY[this.currentPlayer];\n        },\n        get: function get() {\n            return this._turnNumber;\n        }\n    }, {\n        key: 'stateHistory',\n        set: function set(statesList) {\n            var _this6 = this,\n                _domElements$historyB;\n\n            /* Update the list of previous game states by creating a board for each step in the history.\n               This field changes after a cell is filled  (or when resetting history to an earlier state)\n             */\n            this._history = statesList;\n\n            var pastBoards = this.stateHistory.map(function (state) {\n                return _this6.createHistoryBoard(state);\n            });\n            (0, _utils.removeChildren)(this.domElements.historyBoards);\n            (_domElements$historyB = this.domElements.historyBoards).append.apply(_domElements$historyB, _toConsumableArray(pastBoards));\n\n            // Scroll to bottom\n            var container = this.domElements.history;\n            container.scrollTop = container.scrollHeight;\n        },\n        get: function get() {\n            return this._history;\n        }\n\n        /** Computed properties **/\n\n    }, {\n        key: 'currentPlayer',\n        get: function get() {\n            return this.turnNumber % 2 === 0 ? _constants.CELL_STATES.O : _constants.CELL_STATES.X;\n        }\n    }, {\n        key: 'flatCells',\n        get: function get() {\n            var _this7 = this,\n                _ref11;\n\n            /* Each cell in one flat array */\n            var cellsByRow = (0, _utils.range)(this.boardSize).map(function (i) {\n                return (0, _utils.range)(_this7.boardSize).map(function (j) {\n                    return {\n                        row: i,\n                        col: j,\n                        cell: _this7.cellMatrix[i][j]\n                    };\n                });\n            });\n            return (_ref11 = []).concat.apply(_ref11, _toConsumableArray(cellsByRow)); // join all rows together\n        }\n    }]);\n\n    return Game;\n}();\n\nexports.default = Game;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _ripple = __webpack_require__(5);\n\nvar _ripple2 = _interopRequireDefault(_ripple);\n\nvar _constants = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar BoardCell = function () {\n    /* Reflects changes to internal state in the DOM element */\n    function BoardCell(game) {\n        var _this = this;\n\n        _classCallCheck(this, BoardCell);\n\n        this._state = _constants.CELL_STATES.EMPTY;\n        this.game = game;\n\n        this.domElement = document.createElement('td');\n        this.domElement.classList += 'ripple';\n        this.domElement.onclick = function (e) {\n            return _this.fillCell(e);\n        };\n    }\n\n    _createClass(BoardCell, [{\n        key: 'fillCell',\n        value: function fillCell(clickEvent) {\n            var _this2 = this;\n\n            /* Register the click, updating the game state */\n            if (this.game.phase === _constants.GAME_PHASES.OVER) return;\n\n            if (this.state !== _constants.CELL_STATES.EMPTY) // cell is already filled\n                return;\n            this.state = this.game.currentPlayer; // actually set the value\n\n            (0, _ripple2.default)(clickEvent, this.domElement);\n            // Make the cell look non-interactive after the ripple animation is done\n            setTimeout(function () {\n                return _this2.domElement.classList.add('noninteractive');\n            }, 500);\n\n            this.game.advanceTurn();\n        }\n    }, {\n        key: 'state',\n        set: function set(value) {\n            /* Show the corresponding symbol */\n            this._state = value;\n            this.domElement.textContent = _constants.CELL_DISPLAY[value];\n\n            if (value === _constants.CELL_STATES.EMPTY) // empty cell\n                // It will be turned noninteractive when the animation ends\n                this.domElement.classList.remove('noninteractive');\n        },\n        get: function get() {\n            return this._state;\n        }\n    }]);\n\n    return BoardCell;\n}();\n\nexports.default = BoardCell;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction getOrCreate(parent, className) {\n    var elements = parent.getElementsByClassName(className);\n\n    if (elements.length > 0) return elements[0];\n\n    var element = document.createElement('div');\n    element.classList.add(className);\n    parent.prepend(element);\n    return element;\n}\n\nfunction rippleOnClick(event, surface) {\n    /* Material Ripple effect\n       https://github.com/balintsoos/material-ripple\n    */\n\n    // Create .ink element if it doesn't exist\n    var ink = getOrCreate(surface, 'ripple-ink');\n\n    // In case of quick double clicks stop the previous animation\n    ink.classList.remove('animate');\n\n    // Set size of .ink\n    // Use surface's width or height whichever is larger for\n    // the diameter to make a circle which can cover the entire element\n    var diameter = Math.max(surface.offsetHeight, surface.offsetWidth) + 'px';\n    ink.style.height = diameter;\n    ink.style.width = diameter;\n\n    // Cet click coordinates\n    // click coordinates relative to page minus\n    // surface's position relative to page minus\n    // half of self height/width to make it grow from pageY center\n    var x = event.pageX - surface.offsetLeft - ink.offsetWidth / 2;\n    var y = event.pageY - surface.offsetTop - ink.offsetHeight / 2;\n\n    //set the position and add class .animate\n    ink.style.left = x + 'px';\n    ink.style.top = y + 'px';\n    ink.classList.add('animate');\n}\n\nexports.default = rippleOnClick;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction deepCopyArray(arr) {\n    /* Not entirely deep */\n    return Object.assign([], arr);\n}\n\nfunction range(n) {\n    /* range(4) ~> [0, 1, 2, 3] */\n    return [].concat(_toConsumableArray(new Array(n).keys())); // proper use of Array(n), not ineffective\n}\n\nfunction head(array) {\n    /* First element or null */\n    return array.length === 0 ? null : array[0];\n}\n\nfunction parseHtml(templateString) {\n    var parser = new DOMParser();\n    return parser.parseFromString(templateString, 'text/html');\n}\n\nfunction removeChildren(parent) {\n    while (parent.firstChild) {\n        parent.removeChild(parent.firstChild);\n    }\n    return parent;\n}\n\nexports.deepCopyArray = deepCopyArray;\nexports.range = range;\nexports.head = head;\nexports.parseHtml = parseHtml;\nexports.removeChildren = removeChildren;\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 4925b326184029a102fb","const CELL_STATES = Object.freeze({\n    EMPTY: Symbol('Empty Cell'),\n    X    : Symbol('X'),\n    O    : Symbol('O'),\n})\n\nconst CELL_DISPLAY = Object.freeze({\n    [CELL_STATES.EMPTY]: '',\n    [CELL_STATES.X]:     'X',\n    [CELL_STATES.O]:     'O',\n})\n\n\nconst GAME_PHASES = Object.freeze({\n    ACTIVE: Symbol('Game Active'),\n    OVER:   Symbol('Game Over'),\n    DRAW:   Symbol('Draw'),\n})\nconst STATUS_MESSAGES = Object.freeze({\n    [GAME_PHASES.ACTIVE]: 'Next player: ',\n    [GAME_PHASES.OVER]:   'Winner: ',\n    [GAME_PHASES.DRAW]:   'Draw',\n})\nconst WINNING_LINES_DELTAS = [\n    /* A winning line can be vertical, horizontal or diagonal. Each element in this list corresponds to one line.\n       Each line is composed of the center and the two neighbors.\n       The numbers represent the row and column deltas from the center.\n     */\n    [[0,  -1], [0,  +1]], // horizontal line: left, right\n    [[-1,  0], [+1,  0]], // vertical line: above, below\n    [[-1, -1], [+1, +1]], // diagonal line: up-left, down-right\n    [[+1, -1], [-1, +1]], // diagonal line: down-left, up-right\n]\n\nexport {\n    CELL_STATES,\n    CELL_DISPLAY,\n    GAME_PHASES,\n    STATUS_MESSAGES,\n    WINNING_LINES_DELTAS,\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/constants.js","import './style.sass'\nimport Game from './Game'\n\nconst GAMES_ROOT = document.getElementById('games')\nconst BUTTONS = document.getElementsByClassName('add-button')\n\n\nfor (let button of BUTTONS) {\n    const size = button.getAttribute('data-game-size')\n    button.onclick = () => new Game(+size, GAMES_ROOT)\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","import BoardCell from './BoardCell'\nimport {CELL_STATES, CELL_DISPLAY, GAME_PHASES, STATUS_MESSAGES, WINNING_LINES_DELTAS} from './constants'\nimport { deepCopyArray, range, head, parseHtml, removeChildren } from './utils'\n\n\nclass Game {\n    /* Holds the game board (matrix of cells) and game status (game phase, next player and winner).\n       Creates the DOM elements and defines how turns are advanced (fill board cell, switch players);\n       how the game ends (finding a winning line and restricting interactivity)\n       and how the game state is stored as history and reset.\n     */\n\n    constructor(boardSize, rootElement) {\n        /* Initialize internal values and create DOM elements */\n        this.boardSize = boardSize\n\n        this.cellMatrix = this.createCells()\n        this.domElements = this.createDomElements(rootElement)\n\n        this.phase = GAME_PHASES.ACTIVE\n        this.turnNumber = 1\n        this.stateHistory = []\n\n        // this.addCurrentStateToHistory() // add the initial state\n    }\n\n    /** Initialization **/\n    createCells() {\n        /* Create the n by n matrix of (reflective) cells */\n        return range(this.boardSize).map(_ => // create n rows\n            range(this.boardSize).map(_ => new BoardCell(this)) // each containing n cell elements\n        )\n    }\n\n    createDomElements(gamesRoot) {\n        /* Create and insert the into the DOM elements for each part of the game */\n        const template = `\n          <article class=\"game\">\n            \n            <div class=\"active-side\">\n              <p class=\"status\">\n                <span class=\"message\"></span><span class=\"player\"></span>\n              </p>\n              \n              <table class=\"board\">\n              </table>\n            </div>\n\n            <div class=\"history\">\n              <p>History</p>\n              <div class=\"boards\">\n              </div>\n            </div>       \n              \n          </article>\n        `\n        const gameElement = parseHtml(template).getElementsByClassName('game')[0]\n\n        // Insert the rows of cells to the board element\n        const rowElements = this.cellMatrix\n            .map(cells => cells.map(reflectiveCell => reflectiveCell.domElement))\n            .map(cellElements => {\n                const row = document.createElement('tr')\n                row.append(...cellElements)\n                return row\n            })\n\n        const boardElement = gameElement.getElementsByClassName('board')[0]\n        boardElement.append(...rowElements)\n\n        // Insert the newly created game into the container of games\n        gamesRoot.appendChild(gameElement)\n\n        // Height is only evaluated after the element is inserted in the DOM\n        const height = gameElement.getElementsByClassName('active-side')[0].scrollHeight\n        gameElement.getElementsByClassName('history')[0].style.height = height + 'px'\n\n        return {\n            game:          gameElement,\n            message:       gameElement.getElementsByClassName('message')[0],\n            player:        gameElement.getElementsByClassName('player')[0],\n            history:       gameElement.getElementsByClassName('history')[0],\n            historyBoards: gameElement.getElementsByClassName('boards')[0],\n        }\n    }\n\n\n    /** Reflective properties **/\n    set phase(value) {\n        /* Update the displayed message and game class. This field changes when a winning line\n           or a draw was detected after a cell is filled (or when resetting history to an earlier state)\n        */\n        this._phase = value\n\n        if (this.phase === GAME_PHASES.ACTIVE)\n            // Clear previous classes (over/draw)\n            this.domElements.game.classList.remove('game-over', 'draw')\n        else\n            // Add the appropriate game over or draw class\n            this.domElements.game.classList.add(\n                this.phase === GAME_PHASES.OVER ? 'game-over' : 'draw'\n            )\n\n        this.domElements.message.textContent = STATUS_MESSAGES[this.phase]\n    }\n    get phase() { return this._phase }\n\n    set turnNumber(value) {\n        /* Update the displayed player symbol and place the current game state in the history.\n           This field changes after a cell is filled (or when resetting history to an earlier state)\n        */\n        this._turnNumber = value\n        this.domElements.player.textContent = CELL_DISPLAY[this.currentPlayer]\n\n    }\n    get turnNumber() { return this._turnNumber }\n\n    set stateHistory(statesList) {\n        /* Update the list of previous game states by creating a board for each step in the history.\n           This field changes after a cell is filled  (or when resetting history to an earlier state)\n         */\n        this._history = statesList\n\n        const pastBoards = this.stateHistory.map(state => this.createHistoryBoard(state))\n        removeChildren(this.domElements.historyBoards)\n        this.domElements.historyBoards.append(...pastBoards)\n\n        // Scroll to bottom\n        const container = this.domElements.history\n        container.scrollTop = container.scrollHeight\n    }\n    get stateHistory() { return this._history }\n\n\n    /** Computed properties **/\n    get currentPlayer() {\n        return this.turnNumber % 2 === 0 ?\n            CELL_STATES.O :\n            CELL_STATES.X\n    }\n\n    get flatCells() {\n        /* Each cell in one flat array */\n        const cellsByRow = range(this.boardSize).map(i =>\n            range(this.boardSize).map(j => ({\n                row: i,\n                col: j,\n                cell: this.cellMatrix[i][j]\n            }))\n        )\n        return [].concat(...cellsByRow) // join all rows together\n    }\n\n    maybeGetCellState(row, col) {\n        /* The value at the given row and column or null if out of bounds */\n        const n = this.boardSize\n        if (row < 0 || row >= n || col < 0 || col >= this.boardSize)\n            return null\n        return this.cellMatrix[row][col].state\n    }\n\n\n    /** Updating **/\n    advanceTurn() {\n        /* Switch players (X becomes O and vice-versa) and check if game is over or a draw */\n        const winningCoordinates = this.searchWinningCoordinates()\n        if (winningCoordinates !== null) { // actual winning line found\n            this.phase = GAME_PHASES.OVER\n            this.highlightWinner(winningCoordinates)\n            return\n        }\n\n        this.turnNumber += 1\n        if (this.turnNumber > this.boardSize * this.boardSize) {\n            this.phase = GAME_PHASES.DRAW // means it's a draw\n            return\n        }\n\n        this.addCurrentStateToHistory()\n    }\n\n\n    /** Win condition **/\n    searchWinningCoordinates() {\n        /* Return the coordinates of winning triplet of cells (and the symbol that won); null if there is none */\n        const winningLinesInfo = this.flatCells // there can be multiple winning triplets at the same time\n            .map(cellInfo => this.searchWinningNeighbors(cellInfo))\n            .filter(winningLine => winningLine !== null)\n        return head(winningLinesInfo) // first or null\n    }\n\n    searchWinningNeighbors({row, col, cell: center}) {\n        /* Return the coordinates of the winning line (vertical/horizontal/ diagonals); null if there is none. */\n        // There can't be a winner with an empty center (but there can be a hypothetical one\n        if (center.state === CELL_STATES.EMPTY)\n            return null\n\n        const neighborLines = WINNING_LINES_DELTAS.map(lineDeltas => {\n            const neighborCoordinates = lineDeltas.map(([dx, dy]) => [row + dx, col + dy])\n            const neighborValues = neighborCoordinates.map(([x, y]) => this.maybeGetCellState(x, y))\n            // We filter by the values but keep the coordinates\n            return {neighborCoordinates, neighborValues}\n        })\n\n        // There can be multiple winning lines at a time (eg: vertically and horizontally)\n        const winningLines = neighborLines.filter(({neighborCoordinates, neighborValues}) =>\n            // All neighbors must have the same value as the center\n            neighborValues.every(v => v === center.state),\n        )\n\n        if (winningLines.length === 0) // no winning lines found\n            return null\n        return [[row, col], ...winningLines[0].neighborCoordinates]\n    }\n\n    highlightWinner(coordinates) {\n        /* Highlight the cells that caused the win */\n        this.flatCells.forEach(({cell}) => cell\n            .domElement.classList.remove('winner'))\n        coordinates.forEach(([x, y]) => this.cellMatrix[x][y]\n            .domElement.classList.add('winner'))\n    }\n\n\n    /** History **/\n    addCurrentStateToHistory() {\n        /* The current state contains the value of each cell, the next player and the winner status.\n           This method is called after a cell is filled.\n         */\n        // Extract the state from each (reflective) cell in the matrix\n        const cellStateMatrix = this.cellMatrix.map(cellsRow =>\n            cellsRow.map(cell => cell.state),\n        )\n\n        // Create a new one instead of pushing into the old one in order to trigger the setter\n        this.stateHistory = [...this.stateHistory, {\n            cellStateMatrix: cellStateMatrix,\n            phase:      this.phase,\n            turnNumber: this.turnNumber,\n            // The history array is not being saved, instead it will be truncated to previous turns\n        }]\n    }\n\n    resetToState(pastState) {\n        /* Replace the state of each cell, the next player and the winner and keep only previous history steps */\n        for (const {row, col, cell} of this.flatCells)\n            cell.state = pastState.cellStateMatrix[row][col]\n\n        this.phase      = pastState.phase\n        this.turnNumber = pastState.turnNumber\n\n        const truncatedHistory = this.stateHistory.slice(0, pastState.turnNumber) // discard future steps\n        this.stateHistory = deepCopyArray(truncatedHistory)\n    }\n\n    createHistoryBoard(fromState) {\n        /* Populate the board and add the hook to be able to restore to this state when clicked */\n        const rowElements = fromState.cellStateMatrix.map(cellStateRow => {\n            const cellElements = cellStateRow.map(cellState => {\n                const cellElement = document.createElement('td')\n                cellElement.textContent = CELL_DISPLAY[cellState]\n                return cellElement\n            })\n\n            const rowElement = document.createElement('tr')\n            rowElement.append(...cellElements)\n            return rowElement\n        })\n\n        const boardElement = document.createElement('table')\n        boardElement.classList.add('board')\n        boardElement.onclick = () => this.resetToState(fromState)\n        boardElement.append(...rowElements)\n        return boardElement\n    }\n\n\n\n}\n\nexport default Game\n\n\n\n// WEBPACK FOOTER //\n// ./src/Game.js","import rippleOnClick from './ripple'\nimport {CELL_STATES, CELL_DISPLAY, GAME_PHASES} from './constants'\n\n\nclass BoardCell {\n    /* Reflects changes to internal state in the DOM element */\n    constructor(game) {\n        this._state = CELL_STATES.EMPTY\n        this.game = game\n\n        this.domElement = document.createElement('td')\n        this.domElement.classList += 'ripple'\n        this.domElement.onclick = (e) => this.fillCell(e)\n    }\n    set state(value) {\n        /* Show the corresponding symbol */\n        this._state = value\n        this.domElement.textContent = CELL_DISPLAY[value]\n\n        if (value === CELL_STATES.EMPTY)  // empty cell\n            // It will be turned noninteractive when the animation ends\n            this.domElement.classList.remove('noninteractive')\n    }\n    get state() { return this._state }\n\n    fillCell(clickEvent) {\n        /* Register the click, updating the game state */\n        if (this.game.phase === GAME_PHASES.OVER)\n            return\n\n        if (this.state !== CELL_STATES.EMPTY) // cell is already filled\n            return\n        this.state = this.game.currentPlayer // actually set the value\n\n        rippleOnClick(clickEvent, this.domElement)\n        // Make the cell look non-interactive after the ripple animation is done\n        setTimeout(() => this.domElement.classList.add('noninteractive'), 500)\n\n        this.game.advanceTurn()\n    }\n}\n\nexport default BoardCell\n\n\n\n// WEBPACK FOOTER //\n// ./src/BoardCell.js","function getOrCreate(parent, className) {\n    const elements = parent.getElementsByClassName(className)\n\n    if (elements.length > 0)\n        return elements[0]\n\n    const element = document.createElement('div')\n    element.classList.add(className)\n    parent.prepend(element)\n    return element\n}\n\nfunction rippleOnClick(event, surface) {\n    /* Material Ripple effect\n       https://github.com/balintsoos/material-ripple\n    */\n\n    // Create .ink element if it doesn't exist\n    const ink = getOrCreate(surface, 'ripple-ink')\n\n    // In case of quick double clicks stop the previous animation\n    ink.classList.remove('animate');\n\n    // Set size of .ink\n    // Use surface's width or height whichever is larger for\n    // the diameter to make a circle which can cover the entire element\n    let diameter = Math.max(surface.offsetHeight, surface.offsetWidth) + 'px'\n    ink.style.height = diameter\n    ink.style.width  = diameter\n\n    // Cet click coordinates\n    // click coordinates relative to page minus\n    // surface's position relative to page minus\n    // half of self height/width to make it grow from pageY center\n    let x = event.pageX - surface.offsetLeft - (ink.offsetWidth  / 2)\n    let y = event.pageY - surface.offsetTop  - (ink.offsetHeight / 2)\n\n    //set the position and add class .animate\n    ink.style.left = x + 'px'\n    ink.style.top  = y + 'px'\n    ink.classList.add('animate')\n}\n\nexport default rippleOnClick\n\n\n\n// WEBPACK FOOTER //\n// ./src/ripple.js","function deepCopyArray(arr) {\n    /* Not entirely deep */\n    return Object.assign([], arr)\n}\n\nfunction range(n) {\n    /* range(4) ~> [0, 1, 2, 3] */\n    return [...(new Array(n).keys())] // proper use of Array(n), not ineffective\n}\n\nfunction head(array) {\n    /* First element or null */\n    return array.length === 0 ? null : array[0]\n}\n\nfunction parseHtml(templateString) {\n    const parser = new DOMParser()\n    return parser.parseFromString(templateString, 'text/html')\n}\n\nfunction removeChildren(parent) {\n    while (parent.firstChild) {\n        parent.removeChild(parent.firstChild)\n    }\n    return parent\n}\n\nexport {\n    deepCopyArray,\n    range,\n    head,\n    parseHtml,\n    removeChildren,\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js"],"sourceRoot":""}