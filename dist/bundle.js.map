{"version":3,"sources":["webpack:///bundle.js","webpack:///webpack/bootstrap cbf7ac3a76ff99c2ac42","webpack:///./src/index.js","webpack:///./src/Game.js","webpack:///./src/BoardCell.js","webpack:///./src/ripple.js","webpack:///./src/utils.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_Game","_Game2","obj","default","GAMES_ROOT","document","getElementById","BUTTONS","getElementsByClassName","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","button","value","size","getAttribute","onclick","err","return","_toConsumableArray","arr","Array","isArray","arr2","length","from","_classCallCheck","instance","Constructor","TypeError","_slicedToArray","sliceIterator","_arr","_n","_d","_e","_s","_i","push","_createClass","defineProperties","target","props","descriptor","writable","key","protoProps","staticProps","_BoardCell","_utils","WINNING_LINES_DELTAS","Game","rootElement","this","cellMatrix","createCells","domElements","createDomElements","winner","nextPlayer","CELL_STATES","X","stateHistory","addCurrentStateToHistory","_this","range","map","_","BoardCell","gamesRoot","gameElement","parseHtml","template","rowElements","cells","reflectiveCell","domElement","cellElements","row","createElement","append","apply","boardElement","appendChild","height","scrollHeight","style","game","message","player","history","historyBoards","col","state","O","winningNeighbors","findWinner","endGame","_this2","winningLinesInfo","flatCells","cell","findWinningLine","filter","winningLine","head","_ref","_this3","center","EMPTY","neighborLines","lineDeltas","neighborCoordinates","_ref2","_ref3","dx","dy","neighborValues","_ref4","_ref5","x","y","maybeGetCellState","winningLines","_ref6","every","v","coordinates","concat","_ref7","highlightWinner","classList","remove","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","_ref9","_ref10","add","cellStateMatrix","cellsRow","stepNumber","fromState","_this4","cellStateRow","cellState","cellElement","textContent","CELL_DISPLAY","rowElement","resetToState","pastState","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","_ref11","truncatedHistory","slice","deepCopyArray","set","_nextPlayer","_winner","isGameOver","action","statesList","_domElements$historyB","_this5","_history","pastBoards","createHistoryBoard","removeChildren","container","scrollTop","_ref12","_this6","cellsByRow","j","_defineProperty","_Object$freeze","_ripple","_ripple2","freeze","_state","e","fillCell","clickEvent","setTimeout","advanceTurn","rippleOnClick","event","surface","inkElements","ink","prepend","diameter","Math","max","offsetHeight","offsetWidth","width","console","log","pageY","getBoundingClientRect","top","pageX","offsetLeft","offsetTop","left","assign","keys","array","templateString","DOMParser","parseFromString","parent","firstChild","removeChild"],"mappings":"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","file":"bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _Game = __webpack_require__(1);\n\nvar _Game2 = _interopRequireDefault(_Game);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar GAMES_ROOT = document.getElementById('games');\nvar BUTTONS = document.getElementsByClassName('add-button');\n\nvar _loop = function _loop(button) {\n    var size = button.getAttribute('data-game-size');\n    button.onclick = function () {\n        return new _Game2.default(+size, GAMES_ROOT);\n    };\n};\n\nvar _iteratorNormalCompletion = true;\nvar _didIteratorError = false;\nvar _iteratorError = undefined;\n\ntry {\n    for (var _iterator = BUTTONS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var button = _step.value;\n\n        _loop(button);\n    }\n} catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n} finally {\n    try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n        }\n    } finally {\n        if (_didIteratorError) {\n            throw _iteratorError;\n        }\n    }\n}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _BoardCell = __webpack_require__(2);\n\nvar _utils = __webpack_require__(4);\n\n__webpack_require__(5);\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar WINNING_LINES_DELTAS = [\n/* A winning line can be vertical, horizontal or diagonal. Each element in this list corresponds to one line.\n   Each line is composed of the center and the two neighbors.\n   The numbers represent the row and column deltas from the center.\n */\n[[0, -1], [0, +1]], // horizontal line: left, right\n[[-1, 0], [+1, 0]], // vertical line: above, below\n[[-1, -1], [+1, +1]], // diagonal line: up-left, down-right\n[[+1, -1], [-1, +1]]];\n\nvar Game = function () {\n    /* Holds the game board (matrix of cells) and game status (next player and winner).\n       Creates the DOM elements and defines how turns are advanced (fill board cell, switch players);\n       how the game ends (finding a winning line and restricting interactivity)\n       and how the game state is stored as history and reset.\n     */\n\n    function Game(size, rootElement) {\n        _classCallCheck(this, Game);\n\n        /* Initialize internal values and create DOM elements */\n        this.size = size;\n\n        this.cellMatrix = this.createCells();\n        this.domElements = this.createDomElements(rootElement);\n\n        this.winner = null; // can be null, X or O\n        this.nextPlayer = _BoardCell.CELL_STATES.X;\n        this.stateHistory = [];\n\n        this.addCurrentStateToHistory(); // add the initial state\n    }\n\n    /** Initialization **/\n\n\n    _createClass(Game, [{\n        key: 'createCells',\n        value: function createCells() {\n            var _this = this;\n\n            /* Create the n by n matrix of (reflective) cells */\n            return (0, _utils.range)(this.size).map(function (_) {\n                return (// create n rows\n                    (0, _utils.range)(_this.size).map(function (_) {\n                        return new _BoardCell.BoardCell(_this);\n                    })\n                );\n            } // each containing n cell elements\n            );\n        }\n    }, {\n        key: 'createDomElements',\n        value: function createDomElements(gamesRoot) {\n            /* Create and insert the into the DOM elements for each part of the game */\n            var template = '\\n          <article class=\"game\">\\n            \\n            <div class=\"active-side\">\\n              <p class=\"status\">\\n                <span class=\"message\"></span>: \\n                <span class=\"player\"></span>\\n              </p>\\n              \\n              <table class=\"board\">\\n              </table>\\n            </div>\\n\\n            <div class=\"history\">\\n              <p>History</p>\\n              <div class=\"boards\">\\n              </div>\\n            </div>       \\n              \\n          </article>\\n        ';\n            var gameElement = (0, _utils.parseHtml)(template).getElementsByClassName('game')[0];\n\n            // Insert the rows of cells to the board element\n            var rowElements = this.cellMatrix.map(function (cells) {\n                return cells.map(function (reflectiveCell) {\n                    return reflectiveCell.domElement;\n                });\n            }).map(function (cellElements) {\n                var row = document.createElement('tr');\n                row.append.apply(row, _toConsumableArray(cellElements));\n                return row;\n            });\n\n            var boardElement = gameElement.getElementsByClassName('board')[0];\n            boardElement.append.apply(boardElement, _toConsumableArray(rowElements));\n\n            // Insert the newly created game into the container of games\n            gamesRoot.appendChild(gameElement);\n\n            // Height is only evaluated after the element is inserted in the DOM\n            var height = gameElement.getElementsByClassName('active-side')[0].scrollHeight;\n            gameElement.getElementsByClassName('history')[0].style.height = height + 'px';\n\n            return {\n                game: gameElement,\n                message: gameElement.getElementsByClassName('message')[0],\n                player: gameElement.getElementsByClassName('player')[0],\n                history: gameElement.getElementsByClassName('history')[0],\n                historyBoards: gameElement.getElementsByClassName('boards')[0]\n            };\n        }\n\n        /** Reflective properties **/\n\n    }, {\n        key: 'maybeGetCellState',\n        value: function maybeGetCellState(row, col) {\n            /* The value at the given row and column or null if out of bounds */\n            var n = this.size;\n            if (row < 0 || row >= n || col < 0 || col >= this.size) return null;\n            return this.cellMatrix[row][col].state;\n        }\n    }, {\n        key: 'advanceTurn',\n\n\n        /** Updating **/\n        value: function advanceTurn() {\n            /* Switch players (X becomes O and vice-versa) and check if game is over */\n            this.nextPlayer = this.nextPlayer === _BoardCell.CELL_STATES.X ? _BoardCell.CELL_STATES.O : _BoardCell.CELL_STATES.X;\n\n            var winningNeighbors = this.findWinner();\n            if (winningNeighbors !== null) // winning line found\n                this.endGame(winningNeighbors);\n        }\n\n        /** Win condition **/\n\n    }, {\n        key: 'findWinner',\n        value: function findWinner() {\n            var _this2 = this;\n\n            /* Return the coordinates of winning triplet of cells (and the symbol that won), if there is one */\n            var winningLinesInfo = this.flatCells // there can be multiple winning triplets at the same time\n            .map(function (cell) {\n                return _this2.findWinningLine(cell);\n            }).filter(function (winningLine) {\n                return winningLine !== null;\n            });\n            return (0, _utils.head)(winningLinesInfo); // first or null\n        }\n    }, {\n        key: 'findWinningLine',\n        value: function findWinningLine(_ref) {\n            var _this3 = this;\n\n            var row = _ref.row,\n                col = _ref.col,\n                center = _ref.cell;\n\n            /* Return the coordinates of the winning line (left & right / above & below / diagonals) if there is one */\n            if (center.state === _BoardCell.CELL_STATES.EMPTY) // there can't be a winner with an empty center\n                return null;\n\n            var neighborLines = WINNING_LINES_DELTAS.map(function (lineDeltas) {\n                var neighborCoordinates = lineDeltas.map(function (_ref2) {\n                    var _ref3 = _slicedToArray(_ref2, 2),\n                        dx = _ref3[0],\n                        dy = _ref3[1];\n\n                    return [row + dx, col + dy];\n                });\n                var neighborValues = neighborCoordinates.map(function (_ref4) {\n                    var _ref5 = _slicedToArray(_ref4, 2),\n                        x = _ref5[0],\n                        y = _ref5[1];\n\n                    return _this3.maybeGetCellState(x, y);\n                });\n                // We filter by the values but keep the coordinates\n                return { neighborCoordinates: neighborCoordinates, neighborValues: neighborValues };\n            });\n            // There can be multiple winning lines at a time (eg: vertically and horizontally)\n            var winningLines = neighborLines.filter(function (_ref6) {\n                var neighborCoordinates = _ref6.neighborCoordinates,\n                    neighborValues = _ref6.neighborValues;\n                return (\n                    // All neighbors have the same value as the center\n                    neighborValues.every(function (v) {\n                        return v === center.state;\n                    })\n                );\n            });\n\n            if (winningLines.length === 0) // no winning lines found\n                return null;\n            return {\n                player: center.state,\n                coordinates: [[row, col]].concat(_toConsumableArray(winningLines[0].neighborCoordinates))\n            };\n        }\n    }, {\n        key: 'endGame',\n        value: function endGame(_ref7) {\n            var player = _ref7.player,\n                coordinates = _ref7.coordinates;\n\n            /* Mark the game as over by setting the winner. This method is called when a winning line is found. */\n            this.winner = player;\n            this.highlightWinner(coordinates);\n        }\n    }, {\n        key: 'highlightWinner',\n        value: function highlightWinner(coordinates) {\n            /* Highlight the cells that caused the win */\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = this.flatCells[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var _ref8 = _step.value;\n                    var cell = _ref8.cell;\n\n                    cell.domElement.classList.remove('winner');\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = coordinates[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var _ref9 = _step2.value;\n\n                    var _ref10 = _slicedToArray(_ref9, 2);\n\n                    var x = _ref10[0];\n                    var y = _ref10[1];\n\n                    var _cell = this.cellMatrix[x][y];\n                    _cell.domElement.classList.add('winner');\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n        }\n\n        /** History **/\n\n    }, {\n        key: 'addCurrentStateToHistory',\n        value: function addCurrentStateToHistory() {\n            /* The current state contains the value of each cell, the next player and the winner status.\n               This method is called after a cell is filled.\n             */\n            // Extract the state from each (reflective) cell in the matrix\n            var cellStateMatrix = this.cellMatrix.map(function (cellsRow) {\n                return cellsRow.map(function (cell) {\n                    return cell.state;\n                });\n            });\n\n            // Create a new one instead of pushing into the old one in order to trigger the setter\n            this.stateHistory = [].concat(_toConsumableArray(this.stateHistory), [{\n                cellStateMatrix: cellStateMatrix,\n                nextPlayer: this.nextPlayer,\n                winner: this.winner,\n                // The history array is not being saved, instead we mark how much of it should be kept\n                stepNumber: this.stateHistory.length\n            }]);\n        }\n    }, {\n        key: 'createHistoryBoard',\n        value: function createHistoryBoard(fromState) {\n            var _this4 = this;\n\n            /* Populate the board and add the hook to be able to restore to this state when clicked */\n            var rowElements = fromState.cellStateMatrix.map(function (cellStateRow) {\n                var cellElements = cellStateRow.map(function (cellState) {\n                    var cellElement = document.createElement('td');\n                    cellElement.textContent = _BoardCell.CELL_DISPLAY[cellState];\n                    return cellElement;\n                });\n\n                var rowElement = document.createElement('tr');\n                rowElement.append.apply(rowElement, _toConsumableArray(cellElements));\n                return rowElement;\n            });\n\n            var boardElement = document.createElement('table');\n            boardElement.classList.add('board');\n            boardElement.onclick = function () {\n                return _this4.resetToState(fromState);\n            };\n            boardElement.append.apply(boardElement, _toConsumableArray(rowElements));\n            return boardElement;\n        }\n    }, {\n        key: 'resetToState',\n        value: function resetToState(pastState) {\n            /* Replace the state of each cell, the next player and the winner and keep only previous history steps */\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n                for (var _iterator3 = this.flatCells[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                    var _ref11 = _step3.value;\n                    var row = _ref11.row;\n                    var col = _ref11.col;\n                    var cell = _ref11.cell;\n\n                    cell.state = pastState.cellStateMatrix[row][col];\n                }\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                    }\n                } finally {\n                    if (_didIteratorError3) {\n                        throw _iteratorError3;\n                    }\n                }\n            }\n\n            this.nextPlayer = pastState.nextPlayer;\n            this.winner = pastState.winner;\n\n            var truncatedHistory = this.stateHistory.slice(0, pastState.stepNumber + 1); // discard future steps\n            this.stateHistory = (0, _utils.deepCopyArray)(truncatedHistory);\n        }\n    }, {\n        key: 'nextPlayer',\n        set: function set(player) {\n            /* Update the displayed player symbol.\n               This field changes after a cell is filled (or when resetting history to an earlier state)\n            */\n            this._nextPlayer = player; // X or O\n            this.domElements.player.textContent = _BoardCell.CELL_DISPLAY[this.nextPlayer];\n        },\n        get: function get() {\n            return this._nextPlayer;\n        }\n    }, {\n        key: 'winner',\n        set: function set(value) {\n            /* Update the displayed message and symbol: game in progress or game over.\n               This field changes when a winning line was detected after a cell is filled\n               (or when resetting history to an earlier state)\n            */\n            this._winner = value; // null, X or O\n            this.domElements.message.textContent = this.isGameOver ? 'Winner' : 'Next player';\n\n            if (this.isGameOver) this.domElements.player.textContent = _BoardCell.CELL_DISPLAY[this.winner];\n\n            var action = this.isGameOver ? 'add' : 'remove';\n            this.domElements.game.classList[action]('game-over');\n        },\n        get: function get() {\n            return this._winner;\n        }\n    }, {\n        key: 'stateHistory',\n        set: function set(statesList) {\n            var _this5 = this,\n                _domElements$historyB;\n\n            /* Update the list of previous game states by creating a board for each step in the history.\n               This field changes after a cell is filled  (or when resetting history to an earlier state)\n             */\n            this._history = statesList;\n\n            var pastBoards = this.stateHistory.map(function (state) {\n                return _this5.createHistoryBoard(state);\n            });\n            (0, _utils.removeChildren)(this.domElements.historyBoards);\n            (_domElements$historyB = this.domElements.historyBoards).append.apply(_domElements$historyB, _toConsumableArray(pastBoards));\n\n            // Scroll to bottom\n            var container = this.domElements.history;\n            container.scrollTop = container.scrollHeight;\n        },\n        get: function get() {\n            return this._history;\n        }\n\n        /** Computed properties **/\n\n    }, {\n        key: 'flatCells',\n        get: function get() {\n            var _this6 = this,\n                _ref12;\n\n            /* Each cell in one flat array */\n            var cellsByRow = (0, _utils.range)(this.size).map(function (i) {\n                return (0, _utils.range)(_this6.size).map(function (j) {\n                    return {\n                        row: i,\n                        col: j,\n                        cell: _this6.cellMatrix[i][j]\n                    };\n                });\n            });\n            return (_ref12 = []).concat.apply(_ref12, _toConsumableArray(cellsByRow)); // join all rows together\n        }\n    }, {\n        key: 'isGameOver',\n        get: function get() {\n            /* The game is over if there exists a winner */\n            return this.winner !== null;\n        }\n    }]);\n\n    return Game;\n}();\n\nexports.default = Game;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.BoardCell = exports.CELL_DISPLAY = exports.CELL_STATES = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Object$freeze;\n\nvar _ripple = __webpack_require__(3);\n\nvar _ripple2 = _interopRequireDefault(_ripple);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar CELL_STATES = Object.freeze({\n    EMPTY: Symbol('Empty Cell'),\n    X: Symbol('X'),\n    O: Symbol('O')\n});\n\nvar CELL_DISPLAY = Object.freeze((_Object$freeze = {}, _defineProperty(_Object$freeze, CELL_STATES.EMPTY, ''), _defineProperty(_Object$freeze, CELL_STATES.X, 'X'), _defineProperty(_Object$freeze, CELL_STATES.O, 'O'), _Object$freeze));\n\nvar BoardCell = function () {\n    /* Reflects changes to internal state in the DOM element */\n    function BoardCell(game) {\n        var _this = this;\n\n        _classCallCheck(this, BoardCell);\n\n        this._state = CELL_STATES.EMPTY;\n        this.game = game;\n\n        this.domElement = document.createElement('td');\n        this.domElement.classList += 'ripple';\n        this.domElement.onclick = function (e) {\n            return _this.fillCell(e);\n        };\n    }\n\n    _createClass(BoardCell, [{\n        key: 'fillCell',\n        value: function fillCell(clickEvent) {\n            var _this2 = this;\n\n            /* Register the click, updating the game state */\n            if (this.game.isGameOver) return;\n\n            if (this.state !== CELL_STATES.EMPTY) // cell is already filled\n                return;\n            this.state = this.game.nextPlayer; // actually set the value\n\n            (0, _ripple2.default)(clickEvent, this.domElement);\n            // Make the cell look non-interactive after the ripple animation is done\n            setTimeout(function () {\n                return _this2.domElement.classList.add('noninteractive');\n            }, 500);\n\n            this.game.advanceTurn();\n            this.game.addCurrentStateToHistory();\n        }\n    }, {\n        key: 'state',\n        set: function set(value) {\n            /* Show the corresponding symbol */\n            this._state = value;\n            this.domElement.textContent = CELL_DISPLAY[value];\n\n            if (value === CELL_STATES.EMPTY) // empty cell\n                // It will be turned noninteractive when the animation ends\n                this.domElement.classList.remove('noninteractive');\n        },\n        get: function get() {\n            return this._state;\n        }\n    }]);\n\n    return BoardCell;\n}();\n\nexports.CELL_STATES = CELL_STATES;\nexports.CELL_DISPLAY = CELL_DISPLAY;\nexports.BoardCell = BoardCell;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction rippleOnClick(event, surface) {\n    /* Material Ripple effect\n       https://github.com/balintsoos/material-ripple\n    */\n\n    // Create .ink element if it doesn't exist\n    var inkElements = surface.getElementsByClassName('ripple-ink');\n    var ink = void 0;\n    if (inkElements.length === 0) {\n        ink = document.createElement('div');\n        ink.classList.add('ripple-ink');\n        surface.prepend(ink);\n    } else {\n        ink = inkElements[0];\n    }\n\n    // In case of quick double clicks stop the previous animation\n    ink.classList.remove('animate');\n\n    // Set size of .ink\n    // Use surface's width or height whichever is larger for\n    // the diameter to make a circle which can cover the entire element\n    var diameter = Math.max(surface.offsetHeight, surface.offsetWidth) + 'px';\n    ink.style.height = diameter;\n    ink.style.width = diameter;\n\n    // Cet click coordinates\n    // click coordinates relative to page minus\n    // surface's position relative to page minus\n    // half of self height/width to make it grow from pageY center\n    console.log('page y, surface bounding top', event.pageY, surface.getBoundingClientRect().top);\n    var x = event.pageX - surface.offsetLeft - ink.offsetWidth / 2;\n    var y = event.pageY - surface.offsetTop - ink.offsetHeight / 2;\n    console.log(y);\n\n    //set the position and add class .animate\n    ink.style.left = x + 'px';\n    ink.style.top = y + 'px';\n    ink.classList.add('animate');\n}\n\nexports.default = rippleOnClick;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction deepCopyArray(arr) {\n    /* Not entirely deep */\n    return Object.assign([], arr);\n}\n\nfunction range(n) {\n    /* range(4) ~> [0, 1, 2, 3] */\n    return [].concat(_toConsumableArray(new Array(n).keys())); // proper use of Array(n), not ineffective\n}\n\nfunction head(array) {\n    /* First element or null */\n    return array.length === 0 ? null : array[0];\n}\n\nfunction parseHtml(templateString) {\n    var parser = new DOMParser();\n    return parser.parseFromString(templateString, 'text/html');\n}\n\nfunction removeChildren(parent) {\n    while (parent.firstChild) {\n        parent.removeChild(parent.firstChild);\n    }\n    return parent;\n}\n\nexports.deepCopyArray = deepCopyArray;\nexports.range = range;\nexports.head = head;\nexports.parseHtml = parseHtml;\nexports.removeChildren = removeChildren;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap cbf7ac3a76ff99c2ac42","import Game from './Game'\n\nconst GAMES_ROOT = document.getElementById('games')\nconst BUTTONS = document.getElementsByClassName('add-button')\n\n\nfor (let button of BUTTONS) {\n    const size = button.getAttribute('data-game-size')\n    button.onclick = () => new Game(+size, GAMES_ROOT)\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","import { CELL_STATES, CELL_DISPLAY, BoardCell } from './BoardCell'\nimport { deepCopyArray, range, head, parseHtml, removeChildren } from './utils'\nimport './style.sass'\n\n\nconst WINNING_LINES_DELTAS = [\n    /* A winning line can be vertical, horizontal or diagonal. Each element in this list corresponds to one line.\n       Each line is composed of the center and the two neighbors.\n       The numbers represent the row and column deltas from the center.\n     */\n    [[0,  -1], [0,  +1]], // horizontal line: left, right\n    [[-1,  0], [+1,  0]], // vertical line: above, below\n    [[-1, -1], [+1, +1]], // diagonal line: up-left, down-right\n    [[+1, -1], [-1, +1]], // diagonal line: down-left, up-right\n]\n\nclass Game {\n    /* Holds the game board (matrix of cells) and game status (next player and winner).\n       Creates the DOM elements and defines how turns are advanced (fill board cell, switch players);\n       how the game ends (finding a winning line and restricting interactivity)\n       and how the game state is stored as history and reset.\n     */\n\n    constructor(size, rootElement) {\n        /* Initialize internal values and create DOM elements */\n        this.size = size\n\n        this.cellMatrix = this.createCells()\n        this.domElements = this.createDomElements(rootElement)\n\n        this.winner = null // can be null, X or O\n        this.nextPlayer = CELL_STATES.X\n        this.stateHistory = []\n\n        this.addCurrentStateToHistory() // add the initial state\n    }\n\n    /** Initialization **/\n    createCells() {\n        /* Create the n by n matrix of (reflective) cells */\n        return range(this.size).map(_ => // create n rows\n            range(this.size).map(_ => new BoardCell(this)) // each containing n cell elements\n        )\n    }\n\n    createDomElements(gamesRoot) {\n        /* Create and insert the into the DOM elements for each part of the game */\n        const template = `\n          <article class=\"game\">\n            \n            <div class=\"active-side\">\n              <p class=\"status\">\n                <span class=\"message\"></span>: \n                <span class=\"player\"></span>\n              </p>\n              \n              <table class=\"board\">\n              </table>\n            </div>\n\n            <div class=\"history\">\n              <p>History</p>\n              <div class=\"boards\">\n              </div>\n            </div>       \n              \n          </article>\n        `\n        const gameElement = parseHtml(template).getElementsByClassName('game')[0]\n\n        // Insert the rows of cells to the board element\n        const rowElements = this.cellMatrix\n            .map(cells => cells.map(reflectiveCell => reflectiveCell.domElement))\n            .map(cellElements => {\n                const row = document.createElement('tr')\n                row.append(...cellElements)\n                return row\n            })\n\n        const boardElement = gameElement.getElementsByClassName('board')[0]\n        boardElement.append(...rowElements)\n\n        // Insert the newly created game into the container of games\n        gamesRoot.appendChild(gameElement)\n\n        // Height is only evaluated after the element is inserted in the DOM\n        const height = gameElement.getElementsByClassName('active-side')[0].scrollHeight\n        gameElement.getElementsByClassName('history')[0].style.height = height + 'px'\n\n        return {\n            game:          gameElement,\n            message:       gameElement.getElementsByClassName('message')[0],\n            player:        gameElement.getElementsByClassName('player')[0],\n            history:       gameElement.getElementsByClassName('history')[0],\n            historyBoards: gameElement.getElementsByClassName('boards')[0],\n        }\n    }\n\n\n    /** Reflective properties **/\n    set nextPlayer(player) {\n        /* Update the displayed player symbol.\n           This field changes after a cell is filled (or when resetting history to an earlier state)\n        */\n        this._nextPlayer = player // X or O\n        this.domElements.player.textContent = CELL_DISPLAY[this.nextPlayer]\n    }\n    get nextPlayer() { return this._nextPlayer }\n\n    set winner(value) {\n        /* Update the displayed message and symbol: game in progress or game over.\n           This field changes when a winning line was detected after a cell is filled\n           (or when resetting history to an earlier state)\n        */\n        this._winner = value // null, X or O\n        this.domElements.message.textContent =\n            this.isGameOver ? 'Winner' : 'Next player'\n\n        if (this.isGameOver)\n            this.domElements.player.textContent = CELL_DISPLAY[this.winner]\n\n        const action = this.isGameOver ? 'add' : 'remove'\n        this.domElements.game.classList[action]('game-over')\n    }\n    get winner() { return this._winner }\n\n    set stateHistory(statesList) {\n        /* Update the list of previous game states by creating a board for each step in the history.\n           This field changes after a cell is filled  (or when resetting history to an earlier state)\n         */\n        this._history = statesList\n\n        const pastBoards = this.stateHistory.map(state => this.createHistoryBoard(state))\n        removeChildren(this.domElements.historyBoards)\n        this.domElements.historyBoards.append(...pastBoards)\n\n        // Scroll to bottom\n        const container = this.domElements.history\n        container.scrollTop = container.scrollHeight\n    }\n    get stateHistory() { return this._history }\n\n\n    /** Computed properties **/\n    get flatCells() {\n        /* Each cell in one flat array */\n        const cellsByRow = range(this.size).map(i =>\n            range(this.size).map(j => ({\n                row: i,\n                col: j,\n                cell: this.cellMatrix[i][j]\n            }))\n        )\n        return [].concat(...cellsByRow) // join all rows together\n    }\n\n    maybeGetCellState(row, col) {\n        /* The value at the given row and column or null if out of bounds */\n        const n = this.size\n        if (row < 0 || row >= n || col < 0 || col >= this.size)\n            return null\n        return this.cellMatrix[row][col].state\n    }\n\n    get isGameOver() {\n        /* The game is over if there exists a winner */\n        return (this.winner !== null)\n    }\n\n\n    /** Updating **/\n    advanceTurn() {\n        /* Switch players (X becomes O and vice-versa) and check if game is over */\n        this.nextPlayer = (this.nextPlayer === CELL_STATES.X) ?\n            CELL_STATES.O :\n            CELL_STATES.X\n\n        const winningNeighbors = this.findWinner()\n        if (winningNeighbors !== null) // winning line found\n            this.endGame(winningNeighbors)\n    }\n\n\n    /** Win condition **/\n    findWinner() {\n        /* Return the coordinates of winning triplet of cells (and the symbol that won), if there is one */\n        const winningLinesInfo = this.flatCells // there can be multiple winning triplets at the same time\n            .map(cell => this.findWinningLine(cell))\n            .filter(winningLine => winningLine !== null)\n        return head(winningLinesInfo) // first or null\n    }\n\n    findWinningLine({row, col, cell: center}) {\n        /* Return the coordinates of the winning line (left & right / above & below / diagonals) if there is one */\n        if (center.state === CELL_STATES.EMPTY)  // there can't be a winner with an empty center\n            return null\n\n        const neighborLines = WINNING_LINES_DELTAS.map(lineDeltas => {\n            const neighborCoordinates = lineDeltas.map(([dx, dy]) => [row + dx, col + dy])\n            const neighborValues = neighborCoordinates.map(([x, y]) => this.maybeGetCellState(x, y))\n            // We filter by the values but keep the coordinates\n            return {neighborCoordinates, neighborValues}\n        })\n        // There can be multiple winning lines at a time (eg: vertically and horizontally)\n        const winningLines = neighborLines.filter(({neighborCoordinates, neighborValues}) =>\n            // All neighbors have the same value as the center\n            neighborValues.every(v => v === center.state),\n        )\n\n        if (winningLines.length === 0) // no winning lines found\n            return null\n        return {\n            player: center.state,\n            coordinates: [[row, col], ...winningLines[0].neighborCoordinates],\n        }\n    }\n\n    endGame({player, coordinates}) {\n        /* Mark the game as over by setting the winner. This method is called when a winning line is found. */\n        this.winner = player\n        this.highlightWinner(coordinates)\n    }\n\n    highlightWinner(coordinates) {\n        /* Highlight the cells that caused the win */\n        for (const {cell} of this.flatCells)\n            cell.domElement.classList.remove('winner')\n        for (const [x, y] of coordinates) {\n            const cell = this.cellMatrix[x][y]\n            cell.domElement.classList.add('winner')\n        }\n    }\n\n\n    /** History **/\n    addCurrentStateToHistory() {\n        /* The current state contains the value of each cell, the next player and the winner status.\n           This method is called after a cell is filled.\n         */\n        // Extract the state from each (reflective) cell in the matrix\n        const cellStateMatrix = this.cellMatrix.map(cellsRow =>\n            cellsRow.map(cell => cell.state),\n        )\n\n        // Create a new one instead of pushing into the old one in order to trigger the setter\n        this.stateHistory = [...this.stateHistory, {\n            cellStateMatrix: cellStateMatrix,\n            nextPlayer:      this.nextPlayer,\n            winner:          this.winner,\n            // The history array is not being saved, instead we mark how much of it should be kept\n            stepNumber:      this.stateHistory.length,\n        }]\n    }\n\n    createHistoryBoard(fromState) {\n        /* Populate the board and add the hook to be able to restore to this state when clicked */\n        const rowElements = fromState.cellStateMatrix.map(cellStateRow => {\n            const cellElements = cellStateRow.map(cellState => {\n                const cellElement = document.createElement('td')\n                cellElement.textContent = CELL_DISPLAY[cellState]\n                return cellElement\n            })\n\n            const rowElement = document.createElement('tr')\n            rowElement.append(...cellElements)\n            return rowElement\n        })\n\n        const boardElement = document.createElement('table')\n        boardElement.classList.add('board')\n        boardElement.onclick = () => this.resetToState(fromState)\n        boardElement.append(...rowElements)\n        return boardElement\n    }\n\n    resetToState(pastState) {\n        /* Replace the state of each cell, the next player and the winner and keep only previous history steps */\n        for (const {row, col, cell} of this.flatCells)\n            cell.state = pastState.cellStateMatrix[row][col]\n        this.nextPlayer = pastState.nextPlayer\n        this.winner = pastState.winner\n\n        const truncatedHistory = this.stateHistory.slice(0, pastState.stepNumber + 1) // discard future steps\n        this.stateHistory = deepCopyArray(truncatedHistory)\n    }\n\n}\n\nexport default Game\n\n\n\n// WEBPACK FOOTER //\n// ./src/Game.js","import rippleOnClick from './ripple'\n\n\nconst CELL_STATES = Object.freeze({\n    EMPTY: Symbol('Empty Cell'),\n    X    : Symbol('X'),\n    O    : Symbol('O'),\n})\n\nconst CELL_DISPLAY = Object.freeze({\n    [CELL_STATES.EMPTY]: '',\n    [CELL_STATES.X]:     'X',\n    [CELL_STATES.O]:     'O',\n})\n\n\nclass BoardCell {\n    /* Reflects changes to internal state in the DOM element */\n    constructor(game) {\n        this._state = CELL_STATES.EMPTY\n        this.game = game\n\n        this.domElement = document.createElement('td')\n        this.domElement.classList += 'ripple'\n        this.domElement.onclick = (e) => this.fillCell(e)\n    }\n    set state(value) {\n        /* Show the corresponding symbol */\n        this._state = value\n        this.domElement.textContent = CELL_DISPLAY[value]\n\n        if (value === CELL_STATES.EMPTY)  // empty cell\n            // It will be turned noninteractive when the animation ends\n            this.domElement.classList.remove('noninteractive')\n    }\n    get state() { return this._state }\n\n    fillCell(clickEvent) {\n        /* Register the click, updating the game state */\n        if (this.game.isGameOver)\n            return\n\n        if (this.state !== CELL_STATES.EMPTY) // cell is already filled\n            return\n        this.state = this.game.nextPlayer // actually set the value\n\n        rippleOnClick(clickEvent, this.domElement)\n        // Make the cell look non-interactive after the ripple animation is done\n        setTimeout(() => this.domElement.classList.add('noninteractive'), 500)\n\n        this.game.advanceTurn()\n        this.game.addCurrentStateToHistory()\n    }\n}\n\nexport {\n    CELL_STATES,\n    CELL_DISPLAY,\n    BoardCell\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/BoardCell.js","function rippleOnClick(event, surface) {\n    /* Material Ripple effect\n       https://github.com/balintsoos/material-ripple\n    */\n\n    // Create .ink element if it doesn't exist\n    const inkElements = surface.getElementsByClassName('ripple-ink')\n    let ink\n    if (inkElements.length === 0) {\n        ink = document.createElement('div')\n        ink.classList.add('ripple-ink')\n        surface.prepend(ink)\n    }\n    else {\n        ink = inkElements[0]\n    }\n\n    // In case of quick double clicks stop the previous animation\n    ink.classList.remove('animate');\n\n    // Set size of .ink\n    // Use surface's width or height whichever is larger for\n    // the diameter to make a circle which can cover the entire element\n    let diameter = Math.max(surface.offsetHeight, surface.offsetWidth) + 'px'\n    ink.style.height = diameter\n    ink.style.width  = diameter\n\n    // Cet click coordinates\n    // click coordinates relative to page minus\n    // surface's position relative to page minus\n    // half of self height/width to make it grow from pageY center\n    console.log('page y, surface bounding top', event.pageY, surface.getBoundingClientRect().top);\n    let x = event.pageX - surface.offsetLeft - (ink.offsetWidth  / 2)\n    let y = event.pageY - surface.offsetTop  - (ink.offsetHeight / 2)\n    console.log(y);\n\n    //set the position and add class .animate\n    ink.style.left = x + 'px'\n    ink.style.top  = y + 'px'\n    ink.classList.add('animate')\n}\n\nexport default rippleOnClick\n\n\n\n// WEBPACK FOOTER //\n// ./src/ripple.js","function deepCopyArray(arr) {\n    /* Not entirely deep */\n    return Object.assign([], arr)\n}\n\nfunction range(n) {\n    /* range(4) ~> [0, 1, 2, 3] */\n    return [...(new Array(n).keys())] // proper use of Array(n), not ineffective\n}\n\nfunction head(array) {\n    /* First element or null */\n    return array.length === 0 ? null : array[0]\n}\n\nfunction parseHtml(templateString) {\n    const parser = new DOMParser()\n    return parser.parseFromString(templateString, 'text/html')\n}\n\nfunction removeChildren(parent) {\n    while (parent.firstChild) {\n        parent.removeChild(parent.firstChild)\n    }\n    return parent\n}\n\nexport {\n    deepCopyArray,\n    range,\n    head,\n    parseHtml,\n    removeChildren,\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js"],"sourceRoot":""}